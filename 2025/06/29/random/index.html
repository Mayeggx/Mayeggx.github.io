

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/mayegg.png">
  <link rel="icon" href="/img/mayegg.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Mayegg">
  <meta name="keywords" content="">
  
    <meta name="description" content="随机过程复习一 概率论核心定义 随机试验 (E)：一个结果不确定的过程或实验。例如，抛硬币、掷骰子、测量产品的寿命。 样本空间 (Ω)：随机试验所有可能结果的集合。集合中的每个元素（e 或 ω）称为一个样本点。 事件 (A)：样本空间的任意一个子集。我们关心某个事件是否“发生”。 σ-代数 (F)：它是一个由样本空间的子集（即事件）构成的集类（集合的集合） 可测空间 (Ω, F)：由样本空间 Ω">
<meta property="og:type" content="article">
<meta property="og:title" content="随机过程">
<meta property="og:url" content="http://example.com/2025/06/29/random/index.html">
<meta property="og:site_name" content="Mayegg&#39;s Blog">
<meta property="og:description" content="随机过程复习一 概率论核心定义 随机试验 (E)：一个结果不确定的过程或实验。例如，抛硬币、掷骰子、测量产品的寿命。 样本空间 (Ω)：随机试验所有可能结果的集合。集合中的每个元素（e 或 ω）称为一个样本点。 事件 (A)：样本空间的任意一个子集。我们关心某个事件是否“发生”。 σ-代数 (F)：它是一个由样本空间的子集（即事件）构成的集类（集合的集合） 可测空间 (Ω, F)：由样本空间 Ω">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2025-06-29T07:51:17.000Z">
<meta property="article:modified_time" content="2025-06-29T11:52:59.860Z">
<meta property="article:author" content="Mayegg">
<meta name="twitter:card" content="summary_large_image">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>随机过程 - Mayegg&#39;s Blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  



  
<link rel="stylesheet" href="//at.alicdn.com/t/c/font_4692615_syjqch6kdn.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Mayegg&#39;s Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>Home</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>Categories</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>About</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/pokemonDark.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="随机过程"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-06-29 15:51" pubdate>
          June 29, 2025 pm
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          12k words
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          101 mins
        
      </span>
    

    
    
      
        <span id="busuanzi_container_page_pv" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="busuanzi_value_page_pv"></span> views
        </span>
        

      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">随机过程</h1>
            
            
              <div class="markdown-body">
                
                <h3 id="随机过程复习"><a href="#随机过程复习" class="headerlink" title="随机过程复习"></a>随机过程复习</h3><h4 id="一-概率论"><a href="#一-概率论" class="headerlink" title="一 概率论"></a>一 概率论</h4><h5 id="核心定义"><a href="#核心定义" class="headerlink" title="核心定义"></a>核心定义</h5><ul>
<li>随机试验 (E)：一个结果不确定的过程或实验。例如，抛硬币、掷骰子、测量产品的寿命。</li>
<li>样本空间 (Ω)：随机试验所有可能结果的集合。集合中的每个元素（e 或 ω）称为一个样本点。</li>
<li>事件 (A)：样本空间的任意一个子集。我们关心某个事件是否“发生”。</li>
<li>σ-代数 (F)：它是一个由样本空间的子集（即事件）构成的集类（集合的集合）</li>
<li>可测空间 (Ω, F)：由样本空间 Ω 和其上的一个 σ-代数 F 组成的二元组。它搭建了一个舞台，规定了有哪些可能的结果。</li>
<li>测度 (μ)：定义在可测空间 (Ω, F) 上的一个函数，用于“测量”集合的大小。</li>
<li>概率空间 (Ω, F, P)：将以上三者合在一起，就构成了描述一个随机现象的完整数学模型。它包含了所有可能性、所有我们关心的事件组合以及每个事件发生的概率。</li>
</ul>
<blockquote>
<p>💡 形象的例子：给“掷骰子”的舞台配上“概率”</p>
<p>我们继续使用“掷骰子”的例子，并为其分配概率。</p>
<ol>
<li>可测空间 (Ω, F)：我们已经有了舞台。<ul>
<li>Ω = {1, 2, 3, 4, 5, 6}</li>
<li>F = Ω 的幂集 (我们关心所有可能发生的事件)</li>
</ul>
</li>
<li>定义一个“测度” μ：最直观的测度就是“计数”。对于任何事件 A，它的测度就是它包含多少个样本点。<ul>
<li>μ({偶数}) = μ({2, 4, 6}) = 3。</li>
<li>μ({小于3}) = μ({1, 2}) = 2。</li>
</ul>
</li>
<li>定义“概率测度” P：为了让它成为概率，我们需要让所有可能性的“总测度”为1。整个样本空间的测度是 μ(Ω) = 6。所以我们定义概率测度 P(A) = μ(A) / μ(Ω) = |A| / 6。<ul>
<li>P({偶数}) = 3 / 6 = 0.5。</li>
<li>P({小于3}) = 2 / 6 ≈ 0.33。</li>
<li>这符合我们对公平骰子的直观理解。</li>
</ul>
</li>
<li>概率空间 (Ω, F, P)：三者合一，我们就得到了一个完整的模型，可以精确地描述“掷一个公平骰子”这个随机现象。</li>
</ol>
</blockquote>
<h5 id="概率公理"><a href="#概率公理" class="headerlink" title="概率公理"></a>概率公理</h5><ol>
<li>非负性：对任意事件 A，0 ≤ P(A) ≤ 1。</li>
<li>归一化：P(Ω) = 1。</li>
<li>可加性：对于一系列互不相容的事件 A₁, A₂, …，有 P(A₁ ∪ A₂ ∪ …) = P(A₁) + P(A₂) + …。</li>
<li>容斥恒等式：对于任意两个事件 E 和 F，计算它们并集的概率：P(E ∪ F) = P(E) + P(F) - P(EF)</li>
</ol>
<blockquote>
<p>💡 形象的例子：计算重叠部分的概率</p>
<p>假设我们想知道“掷出偶数或大于3的数”的概率。</p>
<ul>
<li>事件 E = “掷出偶数” = {2, 4, 6}，P(E) = 3/6。</li>
<li>事件 F = “掷出大于3的数” = {4, 5, 6}，P(F) = 3/6。</li>
</ul>
<p>如果我们直接相加 P(E) + P(F) = 3/6 + 3/6 = 1，这显然是错的，因为我们把 {4, 6} 这两个结果计算了两次。</p>
<p>容斥恒等式就是为了修正这个问题：</p>
<ol>
<li>加上各自的概率：P(E) + P(F) = 3/6 + 3/6。</li>
<li>减去重叠部分的概率：重叠部分（交集）是 EF = “掷出偶数且大于3的数” = {4, 6}。P(EF) = 2/6。</li>
<li>最终结果：P(E ∪ F) = P(E) + P(F) - P(EF) = 3/6 + 3/6 - 2/6 = 4/6。</li>
</ol>
<p>实际结果是 {2, 4, 5, 6}，确实是4个结果，概率为 4/6。这个原则就像用两个集合的面积减去它们重叠部分的面积来计算总面积一样。</p>
</blockquote>
<h5 id="贝叶斯准则"><a href="#贝叶斯准则" class="headerlink" title="贝叶斯准则"></a>贝叶斯准则</h5><ul>
<li>条件概率：它衡量的是在某个事件 F 已经发生的条件下，另一个事件 E 发生的概率。条件概率是概率论的灵魂之一，它体现了“信息”对可能性的改变。</li>
<li>意义：如果我们观察到了结果（Effect），我们想反过来推断造成这个结果的原因（Cause）的可能性有多大。</li>
<li>公式：<code>P(Aᵢ|B) = [ P(Aᵢ)P(B|Aᵢ) ] / [ Σ P(Aⱼ)P(B|Aⱼ) ]</code></li>
</ul>
<p>例题 以医院检查某种疾病为例，某疾病在所有人群中的感染率是0.1%（即在历史经验中是一个非常罕见的病），医院现有的技术对于该疾病检测准确率为 99%（已知患病情况下，99% 的可能性可以检查出阳性（患病）；已知不患病下 99% 的可能性检查为阴性（正常）。让我们再来计算初检和复检结果的准确性。（阳性时，实际患病的概率）</p>
<p>解题步骤：</p>
<ol>
<li><p>定义事件</p>
<p><code>H</code> (Hypothesis)：代表“该人确实患有此疾病”。<br><code>H&#39;</code> (Not H)：代表“该人没有患病”。<br><code>E</code> (Evidence)：代表“检测结果为阳性”。</p>
</li>
<li><p>整理已知概率</p>
</li>
</ol>
<p>根据题目信息，我们有：</p>
<p>   先验概率 P(H)：人群的感染率。<br>       <code>P(H) = 0.1% = 0.001</code><br>       因此，没有患病的概率是 <code>P(H&#39;) = 1 - P(H) = 0.999</code><br>   似然度 (Likelihood)：检测的准确率。<br>       <code>P(E|H)</code>：患病者被检测出阳性的概率（真阳性率）。<br>           <code>P(E|H) = 99% = 0.99</code><br>       <code>P(E&#39;|H&#39;)</code>：未患病者被检测出阴性的概率（真阴性率）。<br>           <code>P(E&#39;|H&#39;) = 99% = 0.99</code><br>   推导假阳性率：<br>       <code>P(E|H&#39;)</code>：未患病者被错误检测出阳性的概率。<br>           <code>P(E|H&#39;) = 1 - P(E&#39;|H&#39;) = 1 - 0.99 = 0.01</code></p>
<ol>
<li>计算初检为阳性时，实际患病的概率 P(H|E)</li>
</ol>
<p>我们想求的是 <code>P(H|E)</code>，即在检测结果为阳性的条件下，该人确实患病的概率（后验概率）。</p>
<p>根据贝叶斯公式：<br><code>P(H|E) = [ P(E|H)  P(H) ] / P(E)</code></p>
<p>首先，使用全概率定理计算 <code>P(E)</code>，即检测结果为阳性的总概率：<br><code>P(E) = P(E|H)P(H) + P(E|H&#39;)P(H&#39;) = (0.99  0.001) + (0.01  0.999) = 0.01098</code><br><code>P(H|E) = 0.00099 / 0.01098 ≈ 0.09016</code></p>
<p>即使检测准确率高达99%，如果一个人初次检测结果为阳性，他/她实际患病的概率只有约 9%。这个结果非常反直觉，其根本原因在于疾病本身非常罕见（基础概率太低）。大量的健康人（0.999）乘以一个小的假阳性率（0.01）所产生的“假警报”数量，在绝对值上超过了少数病人（0.001）产生的“真警报”。</p>
<ol>
<li>计算复检为阳性时，实际患病的概率</li>
</ol>
<p>现在，我们对初检结果为阳性的人进行第二次检测（复检）。假设两次检测是相互独立的。</p>
<p>   新的事件 E₂：代表“第二次检测结果也为阳性”。<br>   新的先验概率：经过第一次检测后，我们对该人患病可能性的认知已经更新。此时的“先验概率”就是我们上一步算出的后验概率 <code>P(H|E)</code>。 新的 <code>P(H)</code> ≈ 0.09016；新的 <code>P(H&#39;)</code> = 1 - 0.09016 = 0.90984</p>
<p>再次使用全概率定理计算 <code>P(E₂)</code>：`P(E₂) = (0.99  0.09016) + (0.01  0.90984) ≈ 0.09836``</p>
<p>代入贝叶斯公式：<code>P(H|E₂) = 0.08926 / 0.09836 ≈ 0.9075</code></p>
<p>如果一个人连续两次检测结果都为阳性，那么他/她实际患病的概率飙升至约 90.75%。第二次检测有效地排除了第一次检测中的假阳性情况，极大地增强了结果的可信度。</p>
<p>这个例子完美地展示了贝叶斯推断的核心思想：通过不断获取新的证据，来持续更新我们对一个假说的信念强度。对于罕见事件，单次检测的阳性结果需要谨慎对待，而重复、独立的验证是确认的关键。</p>
<h4 id="二-概率模型"><a href="#二-概率模型" class="headerlink" title="二 概率模型"></a>二 概率模型</h4><h5 id="离散随机变量分布"><a href="#离散随机变量分布" class="headerlink" title="离散随机变量分布"></a>离散随机变量分布</h5><ul>
<li>随机变量：随机变量是随机试验结果的一个实值函数。它将样本空间的每一个样本点映射到一个实数。简单来说它就是一个不确定的数。</li>
<li>分布列：或称概率质量函数，直接给出了一个离散随机变量取到每个可能值的概率。</li>
</ul>
<blockquote>
<p>💡 形象的例子：数值-概率对应表</p>
<p>我们继续用”掷骰子”的例子，其中随机变量 <code>X</code> 代表掷出的点数。</p>
<p>分布列就像一张”数值-概率对应表”，它清楚地列出了随机变量 <code>X</code> 所有可能取到的值，以及取到每个值的相应概率。对于一个公平的骰子，它的分布列如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">X 的取值 (x)</th>
<th style="text-align:center">概率 P(X=x)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">1/6</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">1/6</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">1/6</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">1/6</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">1/6</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center">1/6</td>
</tr>
</tbody>
</table>
</div>
</blockquote>
<h5 id="离散概率模型"><a href="#离散概率模型" class="headerlink" title="离散概率模型"></a>离散概率模型</h5><h6 id="二项分布"><a href="#二项分布" class="headerlink" title="二项分布"></a>二项分布</h6><ul>
<li>描述：在一系列固定的、独立的“是/非”试验（伯努利试验）中，成功次数的分布。</li>
<li>公式：<code>P(X=k) = C(n, k)  p^k  (1-p)^(n-k)</code><ul>
<li><code>n</code>: 总试验次数</li>
<li><code>k</code>: 成功次数</li>
<li><code>p</code>: 单次试验的成功概率</li>
</ul>
</li>
<li>形象理解：失败和成功的组合排列的概率。</li>
</ul>
<blockquote>
<p>例题：假设某工厂规定产品的合格率为 97%，现在从一批产品中随机抽取 10 件，问：抽到恰好 1 件不合格品的概率是多少？</p>
<p>解题步骤：</p>
<ol>
<li>确定参数：<ul>
<li>总试验次数 n = 10（抽10件）</li>
<li>单次试验成功概率 p = 0.97（抽到合格品的概率）</li>
<li>失败概率 1-p = 0.03（抽到不合格品的概率）</li>
<li>恰好 1 件不合格，即 9 件合格，k = 9（成功次数）</li>
</ul>
</li>
<li>代入公式：<ul>
<li>计算组合数：C(10, 9) = 10</li>
<li>代入公式：<br><code>P(X=9) = C(10, 9)  (0.97)^9  (0.03)^1 = 10  (0.97)^9  0.03 ≈ 0.227</code></li>
</ul>
</li>
</ol>
<p>所以，抽到恰好1件不合格品的概率约为 22.7%。</p>
</blockquote>
<h6 id="几何分布"><a href="#几何分布" class="headerlink" title="几何分布"></a>几何分布</h6><ul>
<li>描述：在伯努利试验中，为了取得第一次成功所需要进行的试验次数的分布。</li>
<li>公式：<code>P(X=k) = (1-p)^(k-1)  p</code></li>
<li>无记忆性：几何分布的核心特性。如果一个事件在 <code>m</code> 次试验后还未发生，那么它在未来 <code>n</code> 次试验内仍然不发生的概率，与从一开始就进行 <code>n</code> 次试验不发生的概率是相同的。过去的失败历史不会影响未来的概率。</li>
</ul>
<blockquote>
<p>💡 形象例子：抛硬币直到第一次出现正面</p>
<p>假设你在抛一枚均匀的硬币（正反概率各为0.5），你关心的是：第几次抛掷会第一次出现正面？</p>
<ul>
<li>这就是一个典型的几何分布问题。</li>
<li><p>设 X 表示“第一次出现正面所需的抛掷次数”，那么 X 就是一个几何分布的随机变量，p=0.5。</p>
</li>
<li><p>这意味着前两次都是反面，第3次是正面。</p>
</li>
<li>概率计算：P(X=3) = (1-p)^(3-1)  p = (0.5)^2  0.5 = 0.25  0.5 = 0.125</li>
</ul>
</blockquote>
<p>二项分布和随机分布的区别：</p>
<ul>
<li>二项分布：固定次数 → 随机成功次数</li>
<li>几何分布：随机次数 → 固定目标（第一次成功）</li>
</ul>
<h6 id="泊松分布"><a href="#泊松分布" class="headerlink" title="泊松分布"></a>泊松分布</h6><ul>
<li>描述：在一个固定的时间间隔或空间区域内，一个稀有事件发生的次数的分布。这是二项分布的一个特殊情况。</li>
<li>推导：当二项分布的试验次数 <code>n</code> 极大，而单次成功概率 <code>p</code> 极小，其乘积 <code>λ = np</code> 为一个常数时，二项分布近似于泊松分布。</li>
<li>公式：<code>P(X=k) = (λ^k  e^(-λ)) / k!</code><ul>
<li><code>λ</code>: 单位时间/空间内事件的平均发生次数。</li>
</ul>
</li>
<li>适用条件：<ol>
<li>事件是稀有的（概率 <code>p</code> 很小）。</li>
<li>事件的发生是相互独立的。</li>
<li>事件发生的速率是恒定的。</li>
</ol>
</li>
</ul>
<blockquote>
<p>💡 形象例子：急救中心报警电话</p>
<p>题目：<br>某城市的一个急救中心，平均每小时接到 2 次事故报警电话。假设每次报警都是独立的，并且报警的速率是恒定的。</p>
<p>请问：</p>
<ol>
<li>在接下来的一个小时内，恰好接到 3 次报警电话的概率是多少？</li>
<li>在接下来的一个小时内，一次报警电话都没接到的概率是多少？</li>
</ol>
<p>解题步骤：</p>
<ol>
<li><p>确定模型和参数:</p>
<ul>
<li>这是一个典型的泊松分布问题。</li>
<li>时间单位是“1小时”。</li>
<li>平均发生率 <code>λ = 2</code> (次/小时)。</li>
</ul>
</li>
<li><p>问题1：计算恰好接到 3 次电话 (k=3) 的概率</p>
<ul>
<li>代入公式 <code>P(X=k) = (λ^k  e^(-λ)) / k!</code></li>
<li><code>P(X=3) = (2³  e⁻²) / 3!</code></li>
<li><code>P(X=3) = (8  e⁻²) / (3  2  1)</code></li>
<li><code>P(X=3) = (8  0.1353) / 6</code></li>
<li><code>P(X=3) ≈ 0.1804</code></li>
</ul>
</li>
<li><p>问题2：计算一次电话都没接到 (k=0) 的概率</p>
<ul>
<li>代入公式 <code>P(X=k) = (λ^k  e^(-λ)) / k!</code></li>
<li><code>P(X=0) = (2⁰  e⁻²) / 0!</code>  (记住: <code>x⁰ = 1</code>, <code>0! = 1</code>)</li>
<li><code>P(X=0) = (1  e⁻²) / 1</code></li>
<li><code>P(X=0) ≈ 0.1353</code></li>
</ul>
</li>
</ol>
<p>答案：</p>
<ul>
<li>在接下来的一个小时内，恰好接到3次报警电话的概率约为 18.04%。</li>
<li>在接下来的一个小时内，一次报警电话都没接到的概率约为 13.53%。</li>
</ul>
</blockquote>
<h5 id="连续随机变量分布"><a href="#连续随机变量分布" class="headerlink" title="连续随机变量分布"></a>连续随机变量分布</h5><ol>
<li>概率密度函数 (Probability Density Function, PDF)<ul>
<li>定义：<code>f(x)</code> 描述了连续随机变量在某一点 <code>x</code> 附近的概率密度。</li>
<li>意义：单点的概率没有意义，我们就换个思路：变量落在一个点x附近一个极小区间内的可能性有多大。</li>
<li>例子：PDF <code>f(x)</code> 就像是人口密度。在市中心，人口密度高（<code>f(x)</code>值大）；在郊区，人口密度低（<code>f(x)</code>值小）。</li>
</ul>
</li>
<li>累积分布函数 (Cumulative Distribution Function, CDF)<ul>
<li>定义：<code>F(x) = P(X ≤ x)</code>，表示随机变量 <code>X</code> 的取值小于或等于 <code>x</code> 的累积概率。</li>
<li>意义：直接计算区间的概率，不需要做积分</li>
<li>例子：一场马拉松比赛，选手们的完赛时间是连续的。CDF <code>F(t)</code> 就像是一个进度报告，它回答：“到 <code>t</code> 小时为止，总共有百分之多少的选手已经完成了比赛？”<code>F(3小时) = 0.1</code> 意味着到3小时为止，10%的选手已完赛。</li>
</ul>
</li>
</ol>
<h5 id="常见连续概率模型"><a href="#常见连续概率模型" class="headerlink" title="常见连续概率模型"></a>常见连续概率模型</h5><h6 id="指数分布"><a href="#指数分布" class="headerlink" title="指数分布"></a>指数分布</h6><p>想象一下，你正在一个公交站等车。这个站点的公交车有个特点：它们的到来是完全随机的，但平均每 10 分钟会来一辆。</p>
<ul>
<li>泊松分布关心的问题：在未来一小时内，会来几辆车？（答案：一个离散的数字，如0, 1, 2…）</li>
<li><p>指数分布关心的问题：你到达公交站后，需要等多久才能等到下一辆车？（答案：一个连续的时间，如5.3分钟, 12.1分钟…）</p>
</li>
<li><ol>
<li>核心参数 <code>λ</code> (Lambda)<ul>
<li><code>λ</code> 是速率参数，代表“单位时间内事件发生的平均次数”。</li>
<li>在我们的例子中，平均10分钟来一辆车，所以速率 <code>λ = 1/10 = 0.1</code> (辆/分钟)。</li>
<li><code>λ</code> 越高（车来得越频繁），你平均等待的时间就越短。</li>
</ul>
</li>
</ol>
</li>
<li><ol>
<li>分布的形状：急剧下降的曲线。指数分布的概率密度函数 (PDF) <code>f(t) = λ  e^(-λt)</code> 是一条从左到右急剧下降的曲线。这完全符合我们日常等车、等外卖的直觉。短时间等待的概率很高，长时间等待的概率很低。</li>
</ol>
</li>
<li><ol>
<li>核心特性：无记忆性 (Memorylessness)。这是指数分布最反直觉但又最重要的特性。公交车系统没有“记忆”。它不会因为你已经等了很久就“可怜”你，从而“加快”下一辆车的到来。你已经付出的5分钟等待时间，对于未来而言，是沉没成本，对未来没有任何影响。</li>
</ol>
</li>
</ul>
<blockquote>
<p>例题： 平均每10分钟来一辆车的公交站。你刚到车站。</p>
<p>请问：你需要等待超过15分钟的概率是多少？</p>
<p>解题步骤：</p>
<ol>
<li>确定模型和参数:<ul>
<li>等待时间 <code>T</code> 服从指数分布。</li>
<li>速率参数 <code>λ = 1/10 = 0.1</code> (辆/分钟)。</li>
</ul>
</li>
<li>确定要求解的概率:<ul>
<li>我们要求 <code>P(T &gt; 15)</code>。</li>
</ul>
</li>
<li>使用累积分布函数 (CDF):<ul>
<li>指数分布的CDF（即等待时间不超过 <code>t</code> 的概率）是 <code>F(t) = P(T ≤ t) = 1 - e^(-λt)</code>。</li>
<li>因此，等待时间超过 <code>t</code> 的概率就是 <code>P(T &gt; t) = 1 - P(T ≤ t) = 1 - (1 - e^(-λt)) = e^(-λt)</code>。</li>
</ul>
</li>
<li>代入计算:<ul>
<li><code>P(T &gt; 15) = e^(-0.1  15)</code></li>
<li><code>P(T &gt; 15) = e^(-1.5)</code></li>
<li><code>P(T &gt; 15) ≈ 0.223</code></li>
</ul>
</li>
</ol>
<p>答案： 你需要等待超过15分钟的概率约为 22.3%。</p>
<p>注意：我们在计算中使用的 <code>e^(-λt)</code> 公式，本身就是对 PDF <code>λ  e^(-λt)</code> 积分后的结果。积分这个动作“处理”掉了前面的 <code>λ</code>，从而得到了一个可以直接计算出概率的简洁公式。注意区分连续随机变量中概率密度函数 (PDF) 和累积分布函数 (CDF) 的应用场景的区别。</p>
</blockquote>
<h6 id="埃尔朗分布"><a href="#埃尔朗分布" class="headerlink" title="埃尔朗分布"></a>埃尔朗分布</h6><ul>
<li>概念：指数分布是“等一件事发生”，埃尔朗分布是“等连续 <code>k</code> 件事都发生”。</li>
<li>例子：假设一个电话亭，每个人打电话的时间都服从相同的指数分布。你前面排了 <code>k-1</code> 个人，那么你从现在开始，直到你打完电话所需要的总时间，就服从埃尔朗分布。</li>
<li>为什么需要它：因为它为多阶段、串行的过程提供了模型。现实世界中很多任务不是一步完成的（如微服务调用链、生产线上的多个工序），指数分布无法描述总耗时，埃尔朗分布填补了这个空白。</li>
</ul>
<h6 id="伽玛分布"><a href="#伽玛分布" class="headerlink" title="伽玛分布"></a>伽玛分布</h6><ul>
<li>概念：如果说埃尔朗分布是把整数个“指数分布积木”搭起来，那伽玛分布就是允许你用“2.5块”或“0.8块”这样的非整数积木来搭建模型。</li>
<li>为什么需要它：<ol>
<li>极大的灵活性：现实世界的数据不总是能完美地用“整数个阶段”来解释。伽玛分布的形状参数 <code>α</code> 可以是任意正实数，这让它能拟合各种各样形态的等待时间数据，成为一个非常灵活和强大的“万能”等待时间模型。</li>
<li>理论上的统一：它是指数分布、埃尔朗分布、卡方分布的“父类”，将这些看似不同的分布统一在一个更广义的框架下。</li>
</ol>
</li>
</ul>
<h6 id="正态分布"><a href="#正态分布" class="headerlink" title="正态分布"></a>正态分布</h6><ul>
<li>概念：想象一下，对于一个自然现象（比如身高），存在一个最常见的“平均值”。大部分人都接近这个平均值，而特别高或特别矮的人都比较少。正态分布就是描述这种“中间多，两头少”的对称分布形态的数学模型。它就像是许多随机过程叠加后的最终结果，是自然界和人类社会的一种“稳定状态”或“默认设置”。</li>
<li>参数：均值 <code>μ</code> 和标准差 <code>σ</code>。</li>
<li>3σ原则：<ul>
<li>约 68.3% 的数据落在 <code>(μ-σ, μ+σ)</code> 区间内。</li>
<li>约 95.4% 的数据落在 <code>(μ-2σ, μ+2σ)</code> 区间内。</li>
<li>约 99.7% 的数据落在 <code>(μ-3σ, μ+3σ)</code> 区间内。</li>
</ul>
</li>
</ul>
<blockquote>
<p>例题：利用3σ原则估算考试分数</p>
<p>题目：<br>假设某次大型考试的成绩服从正态分布，平均分 <code>μ = 75</code> 分，标准差 <code>σ = 10</code> 分。</p>
<p>请问：</p>
<ol>
<li>随机抽取一名考生，他的分数在 65分 到 85分 之间的概率大约是多少？</li>
<li>随机抽取一名考生，他的分数高于 95分 的概率大约是多少？</li>
</ol>
<p>解题步骤：</p>
<ol>
<li><p>问题1：分数在 [65, 85] 之间的概率</p>
<ul>
<li>分析区间：65分 = 75 - 10 = <code>μ - σ</code>；85分 = 75 + 10 = <code>μ + σ</code>。</li>
<li>这个区间正好是 <code>(μ-σ, μ+σ)</code>。</li>
<li>根据3σ原则，落在这个区间内的概率约为 68.3%。</li>
</ul>
</li>
<li><p>问题2：分数高于 95分 的概率</p>
<ul>
<li>分析分数点：95分 = 75 + 210 = <code>μ + 2σ</code>。</li>
<li>根据3σ原则，分数在 <code>(μ-2σ, μ+2σ)</code> 区间，即 (55, 95) 分之间的概率约为 95.4%。</li>
<li>这意味着，分数落在该区间之外（即低于55分或高于95分）的总概率是 <code>100% - 95.4% = 4.6%</code>。</li>
<li>由于正态分布是对称的，这 4.6% 的概率被均匀地分在两端。</li>
<li>因此，分数高于 95分 的概率是 <code>4.6% / 2 =</code> 2.3%。</li>
</ul>
</li>
</ol>
</blockquote>
<h5 id="随机变量的数字特征"><a href="#随机变量的数字特征" class="headerlink" title="随机变量的数字特征"></a>随机变量的数字特征</h5><ul>
<li>条件期望：在“知道”某个相关事件 <code>Y=y</code> 已经发生的前提下，对随机变量 <code>X</code> 的期望值进行的更新。</li>
<li>条件方差：定义 <code>Var(X|Y=y)</code>：在给定 <code>Y=y</code> 的条件下，<code>X</code> 的方差。它衡量的是在已知部分信息后，<code>X</code> 剩余的不确定性。</li>
<li>全期望定理：一个随机变量的总体期望，等于其在所有可能条件下的条件期望的加权平均值。</li>
<li>全方差公式：总方差 = 条件方差的期望 (组内方差的平均) + 条件期望的方差 (组间方差)。<ul>
<li>组内方差的期望：这部分衡量的是每个模块内部自身的不确定性。</li>
<li>组间方差：衡量的是不同模块之间的平均水平差异，是一种系统的不确定性。</li>
</ul>
</li>
</ul>
<blockquote>
<p> 例题：某软件系统的缺陷修复时间 <code>T</code> (小时) 取决于其所在模块 <code>M</code>。</p>
<ul>
<li>前端模块 (M=FE)：占40%，修复时间均值为2，方差为1。</li>
<li>后端模块 (M=BE)：占35%，修复时间均值为3，方差为2。</li>
<li>数据库模块 (M=DB)：占25%，修复时间均值为5，方差为3。</li>
</ul>
<p>求它们的总体期望。<br>求修复一个随机缺陷所需时间 <code>T</code> 的总方差 <code>Var(T)</code>。</p>
<p>解题步骤：</p>
<ol>
<li><p>应用全方差公式<br><code>Var(T) = E[Var(T|M)] + Var(E[T|M])</code></p>
</li>
<li><p>计算第一部分：<code>E[Var(T|M)]</code> (组内方差的期望)</p>
<ul>
<li>这是各个模块内部方差的加权平均。</li>
<li><code>E[Var(T|M)] = P(M=FE)  Var(T|M=FE) + P(M=BE)  Var(T|M=BE) + P(M=DB)  Var(T|M=DB)</code></li>
<li><code>E[Var(T|M)] = (0.40  1) + (0.35  2) + (0.25  3)</code></li>
<li><code>E[Var(T|M)] = 0.40 + 0.70 + 0.75 = 1.85</code></li>
</ul>
</li>
<li><p>计算第二部分：<code>Var(E[T|M])</code> (组间方差)</p>
<ul>
<li><code>E[T|M]</code> 是一个随机变量，它会根据模块 <code>M</code> 的不同而取不同的值（2, 3, 5）。我们要求这个新随机变量的方差。</li>
<li>首先，计算 <code>E[T|M]</code> 的期望，即 <code>E[T]</code>，使用全期望定理：<br><code>E[E[T|M]] = E[T] = (0.40  2) + (0.35  3) + (0.25  5) = 3.1</code></li>
<li>然后，计算 <code>E[T|M]</code> 的平方的期望 <code>E[(E[T|M])²]</code>：<br><code>E[(E[T|M])²] = P(M=FE)(E[T|M=FE])² + P(M=BE)(E[T|M=BE])² + P(M=DB)(E[T|M=DB])²</code><br><code>E[(E[T|M])²] = (0.40  2²) + (0.35  3²) + (0.25  5²)</code><br><code>E[(E[T|M])²] = (0.40  4) + (0.35  9) + (0.25  25) = 1.6 + 3.15 + 6.25 = 11.0</code></li>
<li>最后，利用方差公式 <code>Var(K) = E[K²] - (E[K])²</code>：<br><code>Var(E[T|M]) = E[(E[T|M])²] - (E[E[T|M]])² = 11.0 - (3.1)² = 11.0 - 9.61 = 1.39</code></li>
</ul>
</li>
<li><p>合并结果</p>
<ul>
<li><code>Var(T) = E[Var(T|M)] + Var(E[T|M]) = 1.85 + 1.39 = 3.24</code></li>
</ul>
</li>
</ol>
<p>答案：<br>它们的总体期望是3.1，修复一个随机缺陷所需时间的总方差为 3.24 小时²。</p>
</blockquote>
<h5 id="矩母函数"><a href="#矩母函数" class="headerlink" title="矩母函数"></a>矩母函数</h5><ul>
<li>定义：<code>M_X(t) = E[e^(tX)]</code>。</li>
<li>核心作用：<ul>
<li>生成矩：通过对MGF求导并令 <code>t=0</code>，可以得到随机变量的各阶矩。<code>E[X^n] = M_X^(n)(0)</code>。</li>
<li>唯一性：矩母函数唯一地确定了一个概率分布。如果两个随机变量有相同的MGF，它们就有相同的分布。</li>
<li>简化运算：独立随机变量之和的MGF等于它们各自MGF的乘积。<code>M_&#123;X+Y&#125;(t) = M_X(t)  M_Y(t)</code>。这使得证明独立随机变量之和的分布变得非常方便（如证明两个独立泊松变量之和仍为泊松分布）。</li>
</ul>
</li>
<li>概念：矩母函数就像一个概率分布的“指纹”或“DNA”。每个常见的概率分布都有一个独一无二的矩母函数。只要你知道了MGF，就等于知道了这个分布的一切。</li>
<li>为什么叫“母函数”：因为它是一个“制造工厂”。通过对这个函数进行求导，你可以源源不断地“生产”出这个分布的所有“矩”（期望、方差、偏度等）。“矩”是描述分布形状特征的关键数值，而MGF是能够生出所有这些矩的“母亲”，故名“矩母函数”。</li>
</ul>
<blockquote>
<p>具体例子：用MGF求指数分布的期望和方差</p>
<p>背景：<br>假设随机变量 <code>X</code> 服从参数为 <code>λ</code> 的指数分布。我们已知其矩母函数为 <code>M_X(t) = λ / (λ - t)</code>。现在我们假装不知道它的期望和方差，用MGF来求。</p>
<p>解题步骤：</p>
<ol>
<li><p>求一阶矩（期望 E[X]）</p>
<ul>
<li>对 <code>M_X(t)</code> 求一阶导数：<br><code>M&#39;_X(t) = d/dt [λ(λ-t)⁻¹] = λ  (-1)(λ-t)⁻²  (-1) = λ / (λ-t)²</code></li>
<li>令 <code>t=0</code>：<br><code>E[X] = M&#39;_X(0) = λ / (λ-0)² = λ / λ² = 1/λ</code></li>
<li>结论：我们成功“生产”出了期望值 <code>1/λ</code>。</li>
</ul>
</li>
<li><p>求二阶矩（E[X²]）</p>
<ul>
<li>对 <code>M&#39;_X(t)</code> 再求一次导数（即求二阶导数）：<br><code>M&#39;&#39;_X(t) = d/dt [λ(λ-t)⁻²] = λ  (-2)(λ-t)⁻³  (-1) = 2λ / (λ-t)³</code></li>
<li>令 <code>t=0</code>：<br><code>E[X²] = M&#39;&#39;_X(0) = 2λ / (λ-0)³ = 2λ / λ³ = 2/λ²</code></li>
<li>结论：我们得到了二阶矩 <code>2/λ²</code>。</li>
</ul>
</li>
<li><p>计算方差 Var(X)</p>
<ul>
<li>利用方差公式 <code>Var(X) = E[X²] - (E[X])²</code>：<br><code>Var(X) = (2/λ²) - (1/λ)² = 2/λ² - 1/λ² = 1/λ²</code></li>
<li>结论：我们最终计算出了方差 <code>1/λ²</code>。</li>
</ul>
</li>
</ol>
</blockquote>
<h4 id="三-随机变量的函数"><a href="#三-随机变量的函数" class="headerlink" title="三 随机变量的函数"></a>三 随机变量的函数</h4><h5 id="单个随机变量的函数"><a href="#单个随机变量的函数" class="headerlink" title="单个随机变量的函数"></a>单个随机变量的函数</h5><ul>
<li>背景：当我们对一个随机变量 <code>X</code> 进行运算（如 <code>Y = X²</code> 或 <code>Y = 2X + 1</code>），得到的新变量 <code>Y</code> 也是一个随机变量。那么，如何从已知的 <code>X</code> 的分布推导出 <code>Y</code> 的分布呢</li>
<li>思路：无论函数 <code>g(X)</code> 多复杂，都可以从 <code>Y</code> 的累积分布函数 (CDF) <code>F_Y(y)</code> 入手。</li>
<li>步骤：<ol>
<li>写出 <code>Y</code> 的CDF定义：<code>F_Y(y) = P(Y ≤ y)</code>。</li>
<li>将 <code>Y = g(X)</code> 代入：<code>P(g(X) ≤ y)</code>。</li>
<li>解出不等式 <code>g(X) ≤ y</code> 中 <code>X</code> 的范围。</li>
<li>在求出的 <code>X</code> 的范围上对 <code>X</code> 的密度函数 <code>f_X(x)</code> 进行积分，得到 <code>F_Y(y)</code>。</li>
<li>对 <code>F_Y(y)</code> 求导，得到 <code>Y</code> 的密度函数 <code>f_Y(y) = d/dy F_Y(y)</code>。</li>
</ol>
</li>
<li>特殊情况<ul>
<li>线性函数：<code>f_Y(y) = (1/|a|)  f_X((y-b)/a)</code></li>
<li>严格单调函数：<code>f_Y(y) = f_X(h(y))  |dh/dy|</code></li>
</ul>
</li>
</ul>
<h5 id="两个随机变量的函数"><a href="#两个随机变量的函数" class="headerlink" title="两个随机变量的函数"></a>两个随机变量的函数</h5><ul>
<li>离散情况：<code>p_Z(z) = Σ_x p_X(x)  p_Y(z-x)</code></li>
<li>连续情况：<code>f_Z(z) = ∫[-∞ to ∞] f_X(x)  f_Y(z-x) dx</code></li>
<li>💡 形象解释：滑动叠加<ul>
<li>想象 <code>f_X(x)</code> 是一个固定的山丘。</li>
<li>把 <code>f_Y(y)</code> 的图像水平翻转，变成 <code>f_Y(-y)</code>，得到另一个山丘。</li>
<li>将翻转后的山丘沿着x轴平移 <code>z</code> 个单位，得到 <code>f_Y(z-x)</code>。</li>
<li>在每个平移位置 <code>z</code>，计算两个山丘重叠部分下方的面积（即两个函数乘积的积分）。这个面积就是 <code>Z=z</code> 时的概率密度。</li>
<li>这个“翻转、平移、算重叠面积”的过程，就是卷积。</li>
</ul>
</li>
</ul>
<h5 id="协方差与相关性"><a href="#协方差与相关性" class="headerlink" title="协方差与相关性"></a>协方差与相关性</h5><h6 id="协方差"><a href="#协方差" class="headerlink" title="协方差"></a>协方差</h6><ul>
<li>定义：<code>cov(X, Y) = E[(X - E[X])(Y - E[Y])] = E[XY] - E[X]E[Y]</code></li>
<li>💡 形象解释：“同向”或“反向”变化的度量<ul>
<li>协方差衡量了两个变量偏离其均值的方向是否一致。</li>
<li><code>cov &gt; 0</code>：正相关。当 <code>X</code> 取大于其均值的值时，<code>Y</code> 也倾向于取大于其均值的值（“同涨同跌”）。</li>
<li><code>cov &lt; 0</code>：负相关。当 <code>X</code> 取大于其均值的值时，<code>Y</code> 倾向于取小于其均值的值（“你涨我跌”）。</li>
<li><code>cov = 0</code>：不相关。两者没有线性的同向/反向变化趋势。注意：不相关不等于独立！</li>
</ul>
</li>
</ul>
<h6 id="相关系数"><a href="#相关系数" class="headerlink" title="相关系数"></a>相关系数</h6><ul>
<li>定义：<code>ρ(X, Y) = cov(X, Y) / (σ_X  σ_Y)</code></li>
<li>💡 形象解释：标准化的协方差，“线性关系”的纯度<ul>
<li>相关系数 <code>ρ</code> 是一个去除了量纲影响的、标准化的协方差。其取值范围在 <code>[-1, 1]</code> 之间。</li>
<li><code>ρ</code> 的绝对值 <code>|ρ|</code> 衡量的是两个变量之间线性关系的强度。</li>
<li><code>ρ = 1</code>：完全正线性相关。所有数据点完美地落在一条斜率为正的直线上。</li>
<li><code>ρ = -1</code>：完全负线性相关。所有数据点完美地落在一条斜率为负的直线上。</li>
<li><code>ρ = 0</code>：线性不相关。两者之间没有直线关系。但可能存在很强的非线性关系（如 <code>Y=X²</code>）。</li>
<li><code>|ρ|</code> 越接近1，线性关系越强；越接近0，线性关系越弱。</li>
</ul>
</li>
<li>示例： 抛 <code>n</code> 次硬币，正面次数 <code>X</code> 和反面次数 <code>Y</code>。因为 <code>X+Y=n</code> 是一个完美的负线性关系，所以 <code>ρ(X, Y) = -1</code>。</li>
</ul>
<h4 id="四-泊松过程"><a href="#四-泊松过程" class="headerlink" title="四 泊松过程"></a>四 泊松过程</h4><h5 id="随机过程"><a href="#随机过程" class="headerlink" title="随机过程"></a>随机过程</h5><ul>
<li>随机过程: $X = {X(t), t \in T}$ 是一族按时间 $t$ 索引的随机变量。</li>
<li>样本路径: 随机过程的一次具体实现，是时间 $t$ 的函数。</li>
<li>独立增量: 对任意 $t_0 &lt; t_1 &lt; \cdots &lt; t_n$，增量 $X(t_1)-X(t_0), X(t_2)-X(t_1), \cdots, X(t_n)-X(t_{n-1})$ 相互独立。</li>
<li>平稳增量: 增量 $X(t+s)-X(t)$ 的分布仅依赖于时间差 $s$，与起点 $t$ 无关。</li>
</ul>
<blockquote>
<p>💡 形象解释：一个醉汉的随机漫步</p>
<p>想象一个站在数轴原点(0点)的醉汉。他每分钟都随机地向左或向右移动一步。</p>
<ul>
<li><p>随机过程: 醉汉在每一时刻 <code>t</code> 的位置 <code>X(t)</code> 是一个随机变量。这一系列无限延伸的位置 <code>&#123;X(0), X(1), X(2), ...&#125;</code> 就构成了一个随机过程。</p>
</li>
<li><p>时间类型: 因为我们是每分钟观察一次他的位置，时间点是离散的 {0, 1, 2, …}，所以这是一个离散时间过程。如果我们用高速摄像机连续不断地记录他的位置，那将是一个连续时间过程。</p>
</li>
<li><p>样本路径: 我们观察了10分钟，记录下他走过的一条具体路径，比如 <code>0 → 1 → 0 → -1 → 0 → 1 → 2 → 1 → 2 → 1</code>。这条具体的路径就是一个样本路径。如果让他重新再走一次，他几乎肯定会走出一条完全不同的路径。</p>
</li>
<li><p>独立增量: 假设醉汉的每一步都是完全随机的，不受之前步数的影响。那么，他在“第1分钟到第2分钟”的位置变化，与他在“第5分钟到第6分钟”的位置变化，是两个相互独立的事件。</p>
</li>
<li><p>平稳增量: 只要时间跨度相同，醉汉位置变化的规律就是一样的。例如，他在“任意1分钟内”（比如从第3分钟到第4分钟）的位置变化，和他在“另外任意1分钟内”（比如从第99分钟到第100分钟）的位置变化的概率分布是完全相同的。这就是平稳增量。</p>
</li>
</ul>
</blockquote>
<h5 id="泊松过程"><a href="#泊松过程" class="headerlink" title="泊松过程"></a>泊松过程</h5><ul>
<li>定义: 一个随机过程 ${N(t), t \geq 0}$，其中 $N(t)$ 表示从0到 $t$ 时刻发生的事件总数。</li>
<li>性质:<ul>
<li>$N(t) \geq 0$ 且为整数。</li>
<li>$t_1 &lt; t_2 \implies N(t_1) \leq N(t_2)$ (单调不减)。</li>
<li>具有独立和平稳增量。</li>
</ul>
</li>
<li>等价定义：<ul>
<li>宏观：任意长度为 $t$ 的区间内，事件数服从均值为 $\lambda t$ 的泊松分布</li>
<li>微观：在极小区间 $h$ 内，事件发生具有稀疏性</li>
</ul>
</li>
<li>内部时间结构：<ul>
<li>来到间隔 (Inter-arrival Time) $X_n$:<ul>
<li>定义：第 $n-1$ 个与第 $n$ 个事件之间的时间间隔。</li>
<li>分布：相互独立，且服从均值为 $1/\lambda$ 的指数分布。</li>
</ul>
</li>
<li>等待时间 (Waiting Time) $S_n$:<ul>
<li>定义：第 $n$ 个事件发生的时刻，$S_n = \sum_{i=1}^n X_i$。</li>
<li>分布：服从参数为 $n$ 和 $\lambda$ 的 Γ (伽玛) 分布。</li>
</ul>
</li>
</ul>
</li>
<li>条件分布：<ul>
<li>单个事件: 已知在 $[0, t]$ 内只发生1个事件 ($N(t)=1$)，那么该事件的发生时刻在 $[0, t]$ 上服从均匀分布。</li>
<li>多个事件: 已知在 $[0, t]$ 内发生了 $n$ 个事件 ($N(t)=n$)，这 $n$ 个事件的发生时刻 $S_1, \cdots, S_n$ 的联合分布，与 $n$ 个在 $[0, t]$ 上独立均匀分布的随机变量的顺序统计量的分布相同。</li>
</ul>
</li>
</ul>
<blockquote>
<p> 💡 形象解释：一家咖啡店的顾客到来过程</p>
<p>想象一家咖啡店，顾客的到来是完全随机的，平均每小时有 <code>λ</code> 位顾客。</p>
<ul>
<li><p>计数过程: 店主有一个计数器。<code>N(t)</code> 就是从开店（0时刻）到 <code>t</code> 时刻，计数器上显示的总顾客人数。这个数字只会增加，不会减少。</p>
</li>
<li><p>泊松过程的定义:</p>
<ul>
<li>宏观视角 (定义1): 店主关心“任意2小时内会来多少人？” 泊松过程告诉他，这个人数服从一个均值为 <code>2λ</code> 的泊松分布。他可以据此计算来8个人、10个人或一个都不来的概率。</li>
<li>微观视角 (定义2): 如果我们把时间放大到毫秒级别，会发现顾客的到来是“稀疏”的，不可能有两个顾客在完全相同的毫秒推进门。这就是泊松过程的稀疏性。</li>
</ul>
</li>
<li><p>内部时间结构:</p>
<ul>
<li>来到间隔 (指数分布): 刚走了一位顾客，店员心想：“下一位顾客还要等多久才会来？” 这个等待时间服从指数分布。这个分布的“无记忆性”意味着，无论上一位顾客是1分钟前走的还是半小时前走的，下一位顾客“还需要等多久”的概率分布是完全一样的。</li>
<li>等待时间 (伽玛分布): 开店时，店主打赌说：“从现在开始，直到第10位顾客进门，总共需要多长时间？” 这个总时间是前10个“来到间隔”之和，它服从伽玛分布。</li>
</ul>
</li>
<li><p>条件分布:</p>
<ul>
<li>店主去仓库待了1小时 (<code>t=1</code>)，回来后发现店里不多不少正好来了3位新顾客 (<code>N(1)=3</code>)。他并不知道这3位顾客是什么时候来的。泊松过程告诉我们，在店主看来，这3位顾客的到达时刻，就像是在这1小时内随机、均匀地撒了3个时间点一样。他们可能都集中在前十分钟，也可能均匀地分布在整个一小时内。</li>
</ul>
</li>
</ul>
<p>💡 基于时间结构的例题</p>
<p>背景：一个网站的服务器平均每分钟收到3个请求，请求的到达过程服从泊松过程。</p>
<ul>
<li>速率 λ: 3 请求/分钟。</li>
</ul>
<p>例题1：关于“来到间隔” (指数分布)</p>
<p>问题：从任意时刻算起，超过30秒（0.5分钟）才收到下一个请求的概率是多少？</p>
<p>分析：</p>
<ul>
<li>“下一个请求到来的时间间隔” $X$ 服从均值为 $1/λ = 1/3$ 分钟的指数分布。</li>
<li>我们要求 $P(X &gt; 0.5)$。</li>
<li>指数分布的生存函数（超过t的概率）为 $P(X &gt; t) = e^{-\lambda t}$。</li>
</ul>
<p>计算：</p>
<ul>
<li>$λ = 3$</li>
<li>$t = 0.5$</li>
<li>$P(X &gt; 0.5) = e^{-3 \times 0.5} = e^{-1.5} \approx 0.223$</li>
</ul>
<p>答案：超过30秒才收到下一个请求的概率约为 22.3%。</p>
<p>例题2：关于“等待时间” (伽玛分布)</p>
<p>问题：从现在开始，需要等待多长时间才能恰好收到第5个请求？求这个等待时间的期望值。</p>
<p>分析：</p>
<ul>
<li>“第5个请求到来的时刻” $S_5$ 是5个独立的、服从指数分布的“来到间隔”之和。</li>
<li>因此，$S_5$ 服从参数为 $n=5$ 和 $λ=3$ 的伽玛分布。</li>
<li>伽玛分布 $Γ(n, λ)$ 的期望值为 $E[S_n] = n / λ$。</li>
</ul>
<p>计算：</p>
<ul>
<li>$n = 5$</li>
<li>$λ = 3$</li>
<li>$E[S_5] = 5 / 3 \approx 1.67$ 分钟。</li>
</ul>
<p>答案：从现在开始，期望需要等待约 1.67分钟 (即1分40秒) 才能收到第5个请求。</p>
</blockquote>
<h5 id="拓展类型"><a href="#拓展类型" class="headerlink" title="拓展类型"></a>拓展类型</h5><ul>
<li>非齐合泊松过程: 事件发生率 $\lambda(t)$ 是时间的函数。一个城市高速公路收费站。在早上7-9点的通勤高峰期，车辆到达的速率 <code>λ(t)</code> 非常高；而在凌晨2-4点，速率 <code>λ(t)</code> 则非常低。这里的事件发生率不再是一个常数，而是随时间 <code>t</code> 变化的函数。</li>
<li>复合泊松过程: 每次事件发生时，伴随一个随机大小的量。形式为 $X(t) = \sum_{i=1}^{N(t)} Y_i$。一家保险公司。理赔申请的到达（事件发生）可以看作一个泊松过程。但每次理赔的金额 <code>Y_i</code> 是一个随机变量（有的赔1千，有的赔10万）。到 <code>t</code> 时刻为止，公司总的理赔金额 <code>X(t)</code> 就是一个复合泊松过程。它是由“来了多少个”和“每个多大”两个随机因素共同决定的。</li>
<li>条件泊松过程: 事件发生率 $\lambda$ 本身是一个随机变量。一个网站服务器收到的请求。我们知道服务器有两种状态：“正常日”和“促销日”。我们事先不知道今天是“正常日”还是“促销日”（比如，促销活动是随机触发的）。这里的发生率 <code>λ</code> 本身就是一个随机变量，它可能等于10，也可能等于500。这就是条件泊松过程。   </li>
</ul>
<h4 id="五-离散的马尔可夫"><a href="#五-离散的马尔可夫" class="headerlink" title="五 离散的马尔可夫"></a>五 离散的马尔可夫</h4><h5 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h5><ul>
<li>马尔可夫性质：马尔可夫性质，又称为“无记忆性”(Memorylessness)，是马尔可夫过程的核心。它指出，一个随机过程的未来状态的条件概率分布，仅仅取决于其当前状态，而与它在当前状态之前的事件序列无关。</li>
<li>离散时间马尔可夫链的定义<ul>
<li><strong>状态空间 (State Space) $S$</strong>: 一个可数集合，包含了所有可能的状态。</li>
<li><strong>转移概率矩阵 (Transition Probability Matrix) $P$</strong>: 一个方阵，其中元素 $P_{ij}$ 表示从状态 $i$ 转移到状态 $j$ 的单步概率。</li>
<li><strong>初始概率分布 (Initial Probability Distribution) $\pi_0$</strong>: 一个行向量，表示在时间步 $0$ 时，系统处于各个状态的概率。</li>
</ul>
</li>
<li>转移概率矩阵<ul>
<li><strong>非负性</strong>: 所有元素 $P_{ij} \ge 0$。</li>
<li><strong>行和为1</strong>: 矩阵的每一行元素之和必须等于 1。这表示从任何一个状态出发，必须转移到状态空间中的某个状态（包括自身）。</li>
</ul>
</li>
</ul>
<h6 id="示例：天气模型"><a href="#示例：天气模型" class="headerlink" title="示例：天气模型"></a>示例：天气模型</h6><p>假设某地的天气只有两种状态：晴天 (Sunny) 和雨天 (Rainy)。状态空间 $S = {\text{Sunny}, \text{Rainy}}$。<br>我们观察到如下转移规律：</p>
<ul>
<li>如果今天晴天，明天有 90% 的概率还是晴天，10% 的概率会下雨。</li>
<li>如果今天雨天，明天有 40% 的概率会转晴，60% 的概率会继续下雨。</li>
</ul>
<p>对应的转移概率矩阵 $P$ 为：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left"></th>
<th style="text-align:left">Sunny</th>
<th style="text-align:left">Rainy</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>Sunny</strong></td>
<td style="text-align:left">0.9</td>
<td style="text-align:left">0.1</td>
</tr>
<tr>
<td style="text-align:left"><strong>Rainy</strong></td>
<td style="text-align:left">0.4</td>
<td style="text-align:left">0.6</td>
</tr>
</tbody>
</table>
</div>
<script type="math/tex; mode=display">
P = \begin{pmatrix} 0.9 & 0.1 \\ 0.4 & 0.6 \end{pmatrix}</script><p>马尔可夫链的行为也可以通过状态转移图来可视化。图中的节点代表状态，带箭头的边代表可能的状态转移，边上的权重则是转移概率。</p>
<p>天气模型的状态转移图如下：</p>
<pre><code class=" mermaid">graph TD
    A[Sunny] --&gt;|0.9| A
    A --&gt;|0.1| B[Rainy]
    B --&gt;|0.4| A
    B --&gt;|0.6| B
</code></pre>
<h5 id="n步转移概率"><a href="#n步转移概率" class="headerlink" title="n步转移概率"></a>n步转移概率</h5><p><strong>Chapman-Kolmogorov 方程</strong> 给出了计算n步转移概率的通用方法：<br>对于任意 $n, m \ge 0$ 和任意状态 $i, j$，有</p>
<script type="math/tex; mode=display">
P_{ij}^{(n+m)} = \sum_{k \in S} P_{ik}^{(n)} P_{kj}^{(m)}</script><p>该方程表明，从 $i$ 到 $j$ 的 $(n+m)$ 步转移，可以分解为先用 $n$ 步从 $i$ 到某个中间状态 $k$，再用 $m$ 步从 $k$ 到 $j$。</p>
<p>假设某地的天气可以用一个双状态的马尔可夫链来描述，状态集 $S = {1 (\text{晴天}), 2 (\text{雨天})}$。<br>其单步转移概率矩阵为：</p>
<script type="math/tex; mode=display">
P = P^{(1)} = \begin{pmatrix} 0.8 & 0.2 \\ 0.6 & 0.4 \end{pmatrix}</script><p>其中 $P<em>{11}=0.8$ 表示今天晴天，明天也晴天的概率是0.8。$P</em>{12}=0.2$ 表示今天晴天，明天下雨的概率是0.2，以此类推。</p>
<p>现在我们想计算 <strong>今天晴天，后天也晴天</strong> 的概率，即 $P_{11}^{(2)}$。</p>
<p>根据 Chapman-Kolmogorov 方程 (取 $n=1, m=1, i=1, j=1$):</p>
<script type="math/tex; mode=display">
P_{11}^{(2)} = \sum_{k \in \{1,2\}} P_{1k}^{(1)} P_{k1}^{(1)} = P_{11}^{(1)}P_{11}^{(1)} + P_{12}^{(1)}P_{21}^{(1)}</script><p>代入数值：</p>
<script type="math/tex; mode=display">
P_{11}^{(2)} = (0.8)(0.8) + (0.2)(0.6) = 0.64 + 0.12 = 0.76</script><p>这个计算的直观解释是：从晴天到两天后的晴天，有两种途径：</p>
<ol>
<li>晴天 -&gt; 晴天 -&gt; 晴天 (概率 $0.8 \times 0.8 = 0.64$)</li>
<li>晴天 -&gt; 雨天 -&gt; 晴天 (概率 $0.2 \times 0.6 = 0.12$)<br>将这两种互斥情况的概率相加，得到总概率 $0.64 + 0.12 = 0.76$。</li>
</ol>
<p>同时，我们也可以通过计算转移矩阵的平方来得到两步转移矩阵 $P^{(2)}$：</p>
<script type="math/tex; mode=display">
P^{(2)} = P^2 = \begin{pmatrix} 0.8 & 0.2 \\ 0.6 & 0.4 \end{pmatrix} \begin{pmatrix} 0.8 & 0.2 \\ 0.6 & 0.4 \end{pmatrix} = \begin{pmatrix} 0.76 & 0.24 \\ 0.72 & 0.28 \end{pmatrix}</script><p>$P^{(2)}$ 的第1行第1列元素正是我们计算出的 $P_{11}^{(2)} = 0.76$。</p>
<h5 id="可达性与不可约"><a href="#可达性与不可约" class="headerlink" title="可达性与不可约"></a>可达性与不可约</h5><ul>
<li><strong>可达 (Accessible)</strong>: 如果从状态 $i$ 出发，经过有限步（$n \ge 0$）能够到达状态 $j$（即 $P_{ij}^{(n)} &gt; 0$），则称状态 $j$ 从状态 $i$ <strong>可达</strong>，记作 $i \to j$。</li>
<li><strong>互通 (Communicate)</strong>: 如果状态 $i$ 和 $j$ 相互可达（即 $i \to j$ 且 $j \to i$），则称 $i$ 和 $j$ <strong>互通</strong>，记作 $i \leftrightarrow j$。</li>
<li><strong>互通类 (Communicating Class)</strong>: 互通关系将状态空间划分为若干个互通类。同一个类中的所有状态都是相互互通的。</li>
<li>如果一个马尔可夫链只包含一个互通类，即链中任意两个状态都是相互互通的，则称该马尔可夫链是<strong>不可约的 (Irreducible)</strong>。否则，称其为<strong>可约的 (Reducible)</strong>。如果不连通就可约。<ul>
<li><strong>判断方法</strong>：检查状态转移图是否为<strong>强连通图</strong>。如果是，则链是不可约的。</li>
<li><strong>天气模型示例</strong>：由于 Sunny $\leftrightarrow$ Rainy，该链是不可约的。</li>
</ul>
</li>
</ul>
<h5 id="周期性"><a href="#周期性" class="headerlink" title="周期性"></a>周期性</h5><ul>
<li><strong>周期 (Period)</strong>: 状态 $i$ 的周期 $d(i)$ 是所有从 $i$ 出发返回到 $i$ 的步数 $n$ 的最大公约数。$d(i) = \text{gcd}{n \ge 1 | P_{ii}^{(n)} &gt; 0}$。</li>
<li><strong>非周期状态 (Aperiodic)</strong>: 如果 $d(i) = 1$，则状态 $i$ 是非周期的。</li>
<li><strong>性质</strong>: 同一个互通类中的所有状态具有相同的周期。因此，我们可以讨论一个不可约马尔可夫链的周期。</li>
<li><strong>判断方法</strong>: 对于一个互通类，只需判断其中一个状态的周期即可。如果一个状态存在自环（即 $P_{ii} &gt; 0$），那么它的周期一定是1，该类就是非周期的。</li>
</ul>
<p><strong>示例1</strong>: 考虑以下马尔可夫链：</p>
<pre><code class=" mermaid">graph TD
    A --&gt; B
    B --&gt; C
    C --&gt; A
</code></pre>
<ul>
<li><strong>计算状态 A 的周期</strong>:<ul>
<li>从状态 A 出发，可以经过 3 步返回 A (A → B → C → A)。</li>
<li>也可以经过 6 步返回 A (A → B → C → A → B → C → A)。</li>
<li>所有可能返回 A 的步数集合为 ${3, 6, 9, \dots}$。</li>
<li>这些步数的最大公约数是 $\text{gcd}(3, 6, 9, \dots) = 3$。</li>
<li>因此，状态 A 的周期 $d(A) = 3$。</li>
</ul>
</li>
<li>由于状态 A, B, C 构成一个互通类，所以 $d(A) = d(B) = d(C) = 3$。该马尔可夫链是周期的，周期为 3。</li>
</ul>
<p><strong>示例2</strong>:考虑以下马尔可夫链：</p>
<pre><code class=" mermaid">graph TD
    A --&gt; A
    A --&gt; B
    B --&gt; C
    C --&gt; A
</code></pre>
<ul>
<li><strong>分析</strong>：<ul>
<li>状态 A 可以通过1步回到自身（A→A），所以 $P_{AA}^{(1)} &gt; 0$。</li>
<li>状态 A 也可以通过3步回到自身（A→B→C→A），所以 $P_{AA}^{(3)} &gt; 0$。</li>
<li>继续分析，A 还可以通过4步（A→A→A→A）、5步（A→A→B→C→A）等回到自身。</li>
</ul>
</li>
</ul>
<p>计算所有可能的步数 $n$，使得 $P_{AA}^{(n)} &gt; 0$，可以发现 $n=1,3,4,5,\ldots$，即 $n \geq 1$ 且 $n \neq 2$。<br>这些步数的最大公约数是1，因此 $d(A) = 1$。</p>
<p><strong>结论</strong>：该马尔可夫链是非周期的（aperiodic）。</p>
<h5 id="平稳分布"><a href="#平稳分布" class="headerlink" title="平稳分布"></a>平稳分布</h5><p>如果一个马尔可夫链的某个概率分布 $\pi$ 使得在经过一次转移后，其概率分布保持不变，那么这个分布 $\pi$ 就被称为<strong>平稳分布</strong>。</p>
<p>平稳分布 $\pi$ 是一个行向量，满足以下条件：</p>
<script type="math/tex; mode=display">
\pi P = \pi</script><p>同时，$\pi$ 的所有分量之和必须为 1。</p>
<p>平稳分布揭示了马尔可夫链在长时间运行后的<strong>长期行为</strong>或<strong>稳态特性</strong>。</p>
<p><strong>存在性与唯一性定理</strong>：对于一个<strong>不可约</strong>且<strong>非周期</strong>的有限状态马尔可夫链，存在唯一的平稳分布 $\pi$。并且，无论初始分布 $\pi_0$ 是什么，当 $n \to \infty$ 时，系统在任意时刻处于状态 $j$ 的概率都会收敛到 $\pi_j$。</p>
<script type="math/tex; mode=display">
\lim_{n \to \infty} P_{ij}^{(n)} = \pi_j, \quad \text{for all } i, j \in S</script><p>这意味着，长期来看，系统处于各个状态的概率与初始状态无关。</p>
<p>设平稳分布为 $\pi = [\pi_S, \pi_R]$，其中 $\pi_S$ 是晴天的概率，$\pi_R$ 是雨天的概率。<br>我们需要解方程组：</p>
<script type="math/tex; mode=display">
[\pi_S, \pi_R] \begin{pmatrix} 0.9 & 0.1 \\ 0.4 & 0.6 \end{pmatrix} = [\pi_S, \pi_R]</script><p>以及</p>
<script type="math/tex; mode=display">
\pi_S + \pi_R = 1</script><p>展开矩阵乘法得到：</p>
<ol>
<li>$0.9 \pi_S + 0.4 \pi_R = \pi_S$</li>
<li>$0.1 \pi_S + 0.6 \pi_R = \pi_R$</li>
<li>$\pi_S + \pi_R = 1$</li>
</ol>
<p>从第一个方程简化得到：$0.4 \pi_R = 0.1 \pi_S \implies \pi_S = 4 \pi_R$。<br>将其代入第三个方程：$4 \pi_R + \pi_R = 1 \implies 5 \pi_R = 1 \implies \pi_R = 0.2$。<br>因此，$\pi_S = 4 \times 0.2 = 0.8$。</p>
<p>所以，该天气模型的平稳分布为 $\pi = [0.8, 0.2]$。这意味着，长期来看，这个地方大约有 80% 的日子是晴天，20% 的日子是雨天。</p>
<h5 id="吸收马尔可夫链"><a href="#吸收马尔可夫链" class="headerlink" title="吸收马尔可夫链"></a>吸收马尔可夫链</h5><h6 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h6><ul>
<li><strong>吸收态 (Absorbing State)</strong>: 如果一个状态 $i$ 一旦进入就无法离开，即 $P_{ii} = 1$，则称状态 $i$ 为吸收态。</li>
<li><strong>吸收马尔可夫链</strong>: 一个马尔可夫链如果至少包含一个吸收态，并且从任意一个非吸收态（暂态）出发，都能在有限步内到达某个吸收态，则称其为吸收马尔可夫链。</li>
</ul>
<p>假设有三个状态：$1$（暂态）、$2$（暂态）、$3$（吸收态）。转移概率如下：</p>
<ul>
<li>从$1$可以以概率$0.5$转移到$2$，以概率$0.5$转移到$3$；</li>
<li>从$2$只能以概率$1$转移到$3$；</li>
<li>$3$为吸收态，$P_{33}=1$。</li>
</ul>
<pre><code class=" mermaid">%% 吸收马尔可夫链状态转移图
graph LR
    1((1))
    2((2))
    3((3))
    1 -- &quot;0.5&quot; --&gt; 2
    1 -- &quot;0.5&quot; --&gt; 3
    2 -- &quot;1&quot; --&gt; 3
    3 -- &quot;1&quot; --&gt; 3
</code></pre>
<p>对于一个吸收马尔可夫链，我们关心两个核心问题：</p>
<ol>
<li>从某个暂态出发，最终被各个吸收态吸收的概率是多少？</li>
<li>从某个暂态出发，到达吸收态之前，平均需要经过多少步？</li>
</ol>
<p>为了分析这些问题，通常将转移矩阵 $P$ 重新排列成标准形式：</p>
<script type="math/tex; mode=display">
P = \begin{pmatrix} Q & R \\ 0 & I \end{pmatrix}</script><p>其中：</p>
<ul>
<li>$Q$: 暂态到暂态的转移概率矩阵。</li>
<li>$R$: 暂态到吸收态的转移概率矩阵。</li>
<li>$0$: 吸收态到暂态的转移概率矩阵（全为0）。</li>
<li>$I$: 吸收态到吸收态的转移概率矩阵（单位阵）。</li>
</ul>
<p><strong>基本吸收矩阵 (Fundamental Matrix)</strong> $N$ 定义为：</p>
<script type="math/tex; mode=display">
N = (I - Q)^{-1} = I + Q + Q^2 + \dots</script><p>矩阵 $N$ 的元素 $N_{ij}$ 表示从暂态 $i$ 出发，在被吸收前，访问暂态 $j$ 的期望次数。</p>
<p><strong>吸收概率 (Absorption Probabilities)</strong>:<br>从暂态出发，最终被各个吸收态吸收的概率矩阵 $B$ 可以通过以下公式计算：</p>
<script type="math/tex; mode=display">
B = N R</script><p>矩阵 $B$ 的元素 $B_{ij}$ 表示从暂态 $i$ 出发，最终被吸收态 $j$ 吸收的概率。</p>
<p><strong>到达吸收态的期望步数 (Expected Steps to Absorption)</strong>:<br>从暂态 $i$ 出发，到达某个吸收态的期望步数 $t_i$ 是矩阵 $N$ 的第 $i$ 行各元素之和。如果 $t$ 是一个列向量，其中每个元素为 $t_i$，则：</p>
<script type="math/tex; mode=display">
t = N \mathbf{1}</script><p>其中 $\mathbf{1}$ 是一个全为1的列向量。</p>
<h6 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h6><p>有三个状态，$1$（暂态）、$2$（暂态）、$3$（吸收态），转移概率如下：</p>
<pre><code class=" mermaid">%% 吸收马尔可夫链状态转移图
graph LR
    1((1))
    2((2))
    3((3))
    1 -- &quot;0.5&quot; --&gt; 2
    1 -- &quot;0.5&quot; --&gt; 3
    2 -- &quot;1&quot; --&gt; 3
    3 -- &quot;1&quot; --&gt; 3
</code></pre>
<p>其转移矩阵 $P$ 为：</p>
<script type="math/tex; mode=display">
P = \begin{pmatrix}
0 & 0.5 & 0.5 \\
0 & 0 & 1 \\
0 & 0 & 1
\end{pmatrix}</script><p>将其按标准形式排列，暂态为$1,2$，吸收态为$3$：</p>
<script type="math/tex; mode=display">
P = \begin{pmatrix}
Q & R \\
0 & I
\end{pmatrix}
=
\begin{pmatrix}
0 & 0.5 & 0.5 \\
0 & 0 & 1 \\
0 & 0 & 1
\end{pmatrix}</script><p>其中</p>
<script type="math/tex; mode=display">
Q = \begin{pmatrix}
0 & 0.5 \\
0 & 0
\end{pmatrix}, \quad
R = \begin{pmatrix}
0.5 \\
1
\end{pmatrix}, \quad
I = \begin{pmatrix}
1 & 0 \\
0 & 1
\end{pmatrix}</script><p><strong>1. 吸收概率 $B = N R$</strong></p>
<p>首先计算基本吸收矩阵 $N = (I - Q)^{-1}$：</p>
<script type="math/tex; mode=display">
I - Q = \begin{pmatrix}
1 & -0.5 \\
0 & 1
\end{pmatrix}</script><p>其逆矩阵为</p>
<script type="math/tex; mode=display">
N = \begin{pmatrix}
1 & 0.5 \\
0 & 1
\end{pmatrix}</script><p>计算 $B = N R$：</p>
<script type="math/tex; mode=display">
B = \begin{pmatrix}
1 & 0.5 \\
0 & 1
\end{pmatrix}
\begin{pmatrix}
0.5 \\
1
\end{pmatrix}
=
\begin{pmatrix}
1 \times 0.5 + 0.5 \times 1 \\
0 \times 0.5 + 1 \times 1
\end{pmatrix}
=
\begin{pmatrix}
1 \\
1
\end{pmatrix}</script><p><strong>结论：</strong></p>
<ul>
<li>从状态$1$或$2$出发，最终被状态$3$吸收的概率都是$1$。</li>
</ul>
<p><strong>2. 到达吸收态的期望步数 $t = N \mathbf{1}$</strong></p>
<p>$\mathbf{1}$为全1列向量：</p>
<script type="math/tex; mode=display">
\mathbf{1} = \begin{pmatrix} 1 \\ 1 \end{pmatrix}</script><script type="math/tex; mode=display">
t = N \mathbf{1} = \begin{pmatrix}
1 & 0.5 \\
0 & 1
\end{pmatrix}
\begin{pmatrix}
1 \\
1
\end{pmatrix}
=
\begin{pmatrix}
1 + 0.5 \\
1
\end{pmatrix}
=
\begin{pmatrix}
1.5 \\
1
\end{pmatrix}</script><p><strong>结论：</strong></p>
<ul>
<li>从状态$1$出发，平均经过$1.5$步到达吸收态；</li>
<li>从状态$2$出发，平均经过$1$步到达吸收态。</li>
</ul>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/" class="category-chain-item">编程学习</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>随机过程</div>
      <div>http://example.com/2025/06/29/random/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>Author</div>
          <div>Mayegg</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>Posted on</div>
          <div>June 29, 2025</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>Updated on</div>
          <div>June 29, 2025</div>
        </div>
      
      
        <div class="license-meta-item">
          <div>Licensed under</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - Attribution">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/06/21/algorithm/" title="算法设计">
                        <span class="hidden-mobile">算法设计</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>Table of Contents</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  





  <script>
  Fluid.utils.createScript('https://lib.baomitu.com/mermaid/8.14.0/mermaid.min.js', function() {
    mermaid.initialize({"theme":"default"});

    Fluid.utils.listenDOMLoaded(function() {
      Fluid.events.registerRefreshCallback(function() {
        if ('mermaid' in window) {
          mermaid.init();
        }
      });
    });
  });
</script>






    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">Keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }

        Fluid.events.registerRefreshCallback(function() {
          if ('MathJax' in window && MathJax.startup.document && typeof MathJax.startup.document.state === 'function') {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
            MathJax.typesetPromise();
          }
        });
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">Blog works best with JavaScript enabled</div>
  </noscript>
</body>
</html>
