<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>后端端知识点概览</title>
    <link href="/2025/05/27/java/"/>
    <url>/2025/05/27/java/</url>
    
    <content type="html"><![CDATA[<h1 id="后端知识点概览"><a href="#后端知识点概览" class="headerlink" title="后端知识点概览"></a>后端知识点概览</h1><p>为了准备面试，需要系统性的学习后端相关的框架，特此总结一番。</p><h3 id="一、Java-核心基础"><a href="#一、Java-核心基础" class="headerlink" title="一、Java 核心基础"></a><strong>一、Java 核心基础</strong></h3><h4 id="语言特性"><a href="#语言特性" class="headerlink" title="语言特性"></a><strong>语言特性</strong></h4><ul><li><strong>平台无关性</strong>：通过 JVM 实现跨平台，Class 字节码统一执行。</li><li><strong>面向对象</strong>：封装、继承、多态（动态绑定）、抽象类与接口（接口默认 <code>static</code>&#x2F;<code>default</code> 方法，抽象类可定义成员变量）。</li><li><strong>内存管理</strong>：自动垃圾回收（GC），<code>finalize()</code> 方法在对象回收前调用。</li></ul><h4 id="关键类与数据结构"><a href="#关键类与数据结构" class="headerlink" title="关键类与数据结构"></a><strong>关键类与数据结构</strong></h4><ul><li><strong>String</strong>：<code>final</code> 不可变，底层 <code>char[]</code>，拼接用 <code>StringBuilder</code>（非线程安全）或 <code>StringBuffer</code>（线程安全）。</li><li><strong>集合框架</strong>：<ul><li><strong>List</strong>：<code>ArrayList</code>（底层 <code>Object[]</code>，初始容量 10，扩容 1.5 倍）、<code>LinkedList</code>（双向链表，适合频繁增删）。</li><li><strong>Set</strong>：<code>HashSet</code>（哈希表）、<code>TreeSet</code>（红黑树，有序）。</li><li><strong>Queue</strong>：<code>Deque</code>（双端队列，<code>LinkedList</code>&#x2F;<code>ArrayDeque</code> 实现）。</li></ul></li><li><strong>Map</strong>：<code>HashMap</code>（哈希表+链表&#x2F;红黑树，初始容量 16，负载因子 0.75，扩容 2 倍）、<code>ConcurrentHashMap</code>（CAS + 分段锁，线程安全）。</li></ul><h4 id="高级特性"><a href="#高级特性" class="headerlink" title="高级特性"></a><strong>高级特性</strong></h4><ul><li><strong>泛型</strong>：编译时类型检查，伪泛型（运行时擦除为 <code>Object</code>），限定符 <code>T extends Father</code>。</li><li><strong>反射</strong>：运行时动态获取类信息，用于动态代理、AOP、注解解析。</li><li><strong>多态</strong>：父类引用指向子类对象，通过方法重写实现不同行为。</li><li><strong>包装类缓存</strong>：<code>Integer</code> 缓存 <code>-128~127</code>，<code>new Integer(127)</code> 与 <code>Integer.valueOf(127)</code> 比较为 <code>false</code>。</li></ul><h3 id="二、JVM（Java-虚拟机）"><a href="#二、JVM（Java-虚拟机）" class="headerlink" title="二、JVM（Java 虚拟机）"></a><strong>二、JVM（Java 虚拟机）</strong></h3><h4 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a><strong>内存结构</strong></h4><ul><li><strong>堆</strong>：存储对象实例，分代 GC（Young 区含 Eden&#x2F;Survivor，Old 区）。</li><li><strong>方法区</strong>（元空间）：存储类元数据、常量池（<code>StringPool</code> 在堆中）。</li><li><strong>虚拟机栈</strong>：每个线程私有，存储局部变量表、操作数栈。</li><li><strong>程序计数器</strong>：记录当前线程执行字节码的位置。</li></ul><h4 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a><strong>类加载机制</strong></h4><ul><li><strong>流程</strong>：加载（二进制流→<code>Class</code> 对象）→ 连接（验证、准备、解析）→ 初始化（执行 <code>&lt;clinit&gt;</code> 方法）。</li><li><strong>双亲委派模型</strong>：避免类重复加载，保证安全性（自定义类加载器需重写 <code>findClass</code>）。</li></ul><h4 id="垃圾回收（GC）"><a href="#垃圾回收（GC）" class="headerlink" title="垃圾回收（GC）"></a><strong>垃圾回收（GC）</strong></h4><ul><li><strong>算法</strong>：标记-清除（碎片）、复制（新生代）、标记-整理（老年代）。</li><li><strong>回收器</strong>：<ul><li><strong>Serial</strong>（单线程，Client 模式）、<strong>ParNew</strong>（多线程，配合 CMS）。</li><li><strong>CMS</strong>（低停顿，标记-清除，可能产生浮动垃圾）。</li><li><strong>G1</strong>（分Region，优先回收价值高的区域，适合大内存）。</li></ul></li><li><strong>调优参数</strong>：<code>-Xms</code>（堆初始大小）、<code>-Xmx</code>（堆最大值）、<code>-XX:+UseG1GC</code>。</li></ul><h3 id="三、JUC（Java-并发包）"><a href="#三、JUC（Java-并发包）" class="headerlink" title="三、JUC（Java 并发包）"></a><strong>三、JUC（Java 并发包）</strong></h3><h4 id="线程与锁"><a href="#线程与锁" class="headerlink" title="线程与锁"></a><strong>线程与锁</strong></h4><ul><li><strong>创建线程</strong>：继承 <code>Thread</code>、实现 <code>Runnable</code>&#x2F;<code>Callable</code>（支持返回值）、线程池（<code>ThreadPoolExecutor</code>）。</li><li><strong>锁机制</strong>：<ul><li>**<code>synchronized</code>**：偏向锁→轻量级锁→重量级锁（Monitor 对象），可锁实例&#x2F;类方法。</li><li>**<code>ReentrantLock</code>**：可重入，支持公平锁、条件变量（<code>Condition</code>）。</li></ul></li><li><strong>原子变量</strong>：<code>AtomicInteger</code>（CAS 实现）、<code>volatile</code>（可见性，禁止指令重排）。</li></ul><h4 id="并发工具类"><a href="#并发工具类" class="headerlink" title="并发工具类"></a><strong>并发工具类</strong></h4><ul><li><strong>AQS（抽象队列同步器）</strong>：<code>ReentrantLock</code>&#x2F;<code>Semaphore</code>&#x2F;<code>CountDownLatch</code> 的底层实现，基于双向链表和 <code>state</code> 变量。</li><li><strong>线程池</strong>：<ul><li><strong>核心参数</strong>：核心线程数、最大线程数、阻塞队列（如 <code>ArrayBlockingQueue</code>）、拒绝策略（<code>AbortPolicy</code>&#x2F;<code>DiscardOldestPolicy</code>）。</li><li><strong>类型</strong>：<code>FixedThreadPool</code>（固定线程数）、<code>CachedThreadPool</code>（灵活回收线程）。</li></ul></li><li>**<code>ThreadLocal</code>**：线程本地变量，每个线程维护独立副本，避免线程安全问题（需手动 <code>remove</code> 防止内存泄漏）。</li></ul><h3 id="四、Spring-框架"><a href="#四、Spring-框架" class="headerlink" title="四、Spring 框架"></a><strong>四、Spring 框架</strong></h3><h4 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a><strong>核心思想</strong></h4><ul><li><strong>IOC（控制反转）</strong>：对象创建由容器管理，通过 <code>@Autowired</code>&#x2F;<code>@Resource</code> 依赖注入。</li><li><strong>AOP（面向切面编程）</strong>：基于动态代理（JDK&#x2F;CGLIB），实现日志、事务等功能，切点表达式 <code>@Pointcut</code>。</li></ul><h4 id="关键组件"><a href="#关键组件" class="headerlink" title="关键组件"></a><strong>关键组件</strong></h4><ul><li><strong>Bean 生命周期</strong>：实例化→依赖注入→<code>BeanPostProcessor</code>→初始化（<code>afterPropertiesSet</code>&#x2F;<code>init-method</code>）→销毁（<code>destroy-method</code>）。</li><li><strong>事务管理</strong>：<code>@Transactional</code> 注解，基于 AOP，默认回滚运行时异常。</li><li><strong>Spring MVC</strong>：DispatcherServlet→HandlerMapping→HandlerAdapter→Controller→视图解析（<code>@Controller</code>&#x2F;<code>@RestController</code>）。</li></ul><h4 id="高级特性-1"><a href="#高级特性-1" class="headerlink" title="高级特性"></a><strong>高级特性</strong></h4><ul><li><strong>循环依赖</strong>：通过三级缓存（singletonObjects、earlySingletonObjects、singletonFactories）解决，构造器注入无法处理。</li><li><strong>自动配置</strong>：<code>@EnableAutoConfiguration</code> 扫描 <code>META-INF/spring.factories</code> 实现开箱即用。</li></ul><h3 id="五、MySQL-数据库"><a href="#五、MySQL-数据库" class="headerlink" title="五、MySQL 数据库"></a><strong>五、MySQL 数据库</strong></h3><h4 id="核心特性"><a href="#核心特性" class="headerlink" title="核心特性"></a><strong>核心特性</strong></h4><ul><li><strong>存储引擎</strong>：<ul><li><strong>InnoDB</strong>：支持事务、行锁、外键，聚簇索引（主键索引存储整行数据）。</li><li><strong>MyISAM</strong>：不支持事务，表锁，适合读多写少场景。</li></ul></li><li><strong>事务隔离级别</strong>：读未提交→读已提交（默认）→可重复读（解决幻读，通过 MVCC）→串行化。</li></ul><h4 id="索引与查询优化"><a href="#索引与查询优化" class="headerlink" title="索引与查询优化"></a><strong>索引与查询优化</strong></h4><ul><li><strong>索引类型</strong>：主键索引、唯一索引、普通索引、联合索引（最左前缀原则）。</li><li><strong>执行计划</strong>：<code>EXPLAIN</code> 分析 <code>type</code>（全表扫描 <code>all</code>→索引扫描 <code>index</code>→范围查询 <code>range</code>→等值查询 <code>ref</code>&#x2F;<code>eq_ref</code>）。</li><li><strong>慢 SQL 优化</strong>：添加覆盖索引、分库分表（水平&#x2F;垂直拆分）、避免索引失效（如左模糊查询、函数计算）。</li></ul><h4 id="锁与日志"><a href="#锁与日志" class="headerlink" title="锁与日志"></a><strong>锁与日志</strong></h4><ul><li><strong>锁机制</strong>：<ul><li><strong>表锁</strong>：元数据锁（MDL）、意向锁（IS&#x2F;IX）。</li><li><strong>行锁</strong>：共享锁（<code>SELECT ... LOCK IN SHARE MODE</code>）、排他锁（<code>SELECT ... FOR UPDATE</code>）。</li></ul></li><li><strong>日志</strong>：<ul><li><strong>Redo Log</strong>：物理日志，用于崩溃恢复（WAL 机制）。</li><li><strong>Bin Log</strong>：逻辑日志，用于主从复制（<code>Statement</code>&#x2F;<code>Row</code> 模式）。</li></ul></li></ul><h3 id="六、Redis-缓存"><a href="#六、Redis-缓存" class="headerlink" title="六、Redis 缓存"></a><strong>六、Redis 缓存</strong></h3><h4 id="数据结构与应用"><a href="#数据结构与应用" class="headerlink" title="数据结构与应用"></a><strong>数据结构与应用</strong></h4><ul><li><strong>String</strong>：计数器（<code>INCR</code>）、分布式锁（<code>SETNX</code>）。</li><li><strong>List</strong>：消息队列（<code>LPUSH</code>&#x2F;<code>RPOP</code>）、栈结构。</li><li><strong>Set</strong>：去重、交集&#x2F;并集（<code>SADD</code>&#x2F;<code>SMEMBERS</code>）。</li><li><strong>ZSet</strong>：排行榜（<code>ZADD</code>&#x2F;<code>ZRANGE</code>），底层跳表（SkipList）。</li><li><strong>Hash</strong>：存储对象（<code>HSET</code>&#x2F;<code>HGET</code>）。</li></ul><h4 id="核心机制"><a href="#核心机制" class="headerlink" title="核心机制"></a><strong>核心机制</strong></h4><ul><li><strong>持久化</strong>：<ul><li><strong>RDB</strong>：全量快照，适合备份（<code>SAVE</code>&#x2F;<code>BGSAVE</code>）。</li><li><strong>AOF</strong>：增量日志，安全性高（<code>appendfsync</code> 策略）。</li></ul></li><li><strong>集群模式</strong>：<ul><li><strong>主从复制</strong>：异步复制，哨兵（Sentinel）自动故障转移。</li><li><strong>分片集群</strong>：哈希槽（16384 个），客户端路由（<code>CRC16</code> 算法）。</li></ul></li><li><strong>缓存问题</strong>：<ul><li><strong>穿透</strong>：布隆过滤器（Bloom Filter）拦截无效请求。</li><li><strong>击穿</strong>：互斥锁（<code>Redisson</code>）或逻辑过期。</li><li><strong>雪崩</strong>：随机 TTL、限流（令牌桶）、降级。</li></ul></li></ul><h3 id="七、消息中间件"><a href="#七、消息中间件" class="headerlink" title="七、消息中间件"></a><strong>七、消息中间件</strong></h3><h4 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a><strong>RabbitMQ</strong></h4><ul><li><strong>核心概念</strong>：Exchange（路由）、Queue（队列）、Binding（绑定），支持 Direct&#x2F;Topic&#x2F;Headers&#x2F;Fanout 路由模式。</li><li><strong>可靠性</strong>：生产者确认（<code>confirm</code> 机制）、消费者手动 ACK、队列&#x2F;交换机持久化。</li><li><strong>延迟队列</strong>：通过 TTL（消息&#x2F;队列过期时间）+ 死信交换机（DLX）实现。</li></ul><h4 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a><strong>Kafka</strong></h4><ul><li><strong>架构设计</strong>：Producer→Topic（分区 Partition）→Broker→Consumer Group（消费者组，分区分配策略）。</li><li><strong>高性能</strong>：顺序读写、零拷贝（<code>sendfile</code>）、批量压缩（<code>LZ4</code>&#x2F;<code>Snappy</code>）。</li><li><strong>可靠性</strong>：分区多副本（ISR 集合）、生产者 <code>acks</code> 配置（<code>0</code>&#x2F;<code>1</code>&#x2F;<code>all</code>）、消费者手动提交偏移量。</li></ul><h3 id="八、中间件与工具"><a href="#八、中间件与工具" class="headerlink" title="八、中间件与工具"></a><strong>八、中间件与工具</strong></h3><ul><li><strong>Nginx</strong>：反向代理、负载均衡（轮询&#x2F;加权轮询&#x2F;IP 哈希）、动静分离、缓存静态资源。</li><li><strong>JWT</strong>：JSON  Web 令牌，用于身份认证（Header-Payload-Signature），刷新令牌（Refresh Token）机制。</li><li><strong>分库分表</strong>：水平拆分（按主键取模）、垂直拆分（按业务模块），路由组件（MyCat&#x2F;Sharding-JDBC）。</li><li><strong>分布式锁</strong>：Redis <code>SETNX</code> + Lua 脚本、Redisson（支持可重入锁&#x2F;公平锁）、Zookeeper（临时有序节点）。</li></ul><h3 id="九、网络与操作系统"><a href="#九、网络与操作系统" class="headerlink" title="九、网络与操作系统"></a><strong>九、网络与操作系统</strong></h3><h4 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a><strong>网络协议</strong></h4><ul><li><strong>HTTP</strong>：<ul><li><strong>1.1</strong>：长连接（<code>Connection: keep-alive</code>）、管道化（队头阻塞问题）。</li><li><strong>2.0</strong>：二进制帧、多路复用、头部压缩（HPACK）。</li><li><strong>3.0</strong>：基于 QUIC 协议，无队头阻塞，1-RTT 握手。</li></ul></li><li><strong>TCP&#x2F;IP</strong>：<ul><li><strong>三次握手</strong>：SYN→SYN+ACK→ACK，防止历史连接初始化。</li><li><strong>四次挥手</strong>：FIN→ACK→FIN→ACK，TIME_WAIT 状态等待 2MSL 确保可靠关闭。</li></ul></li></ul><h4 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a><strong>操作系统</strong></h4><ul><li><strong>进程与线程</strong>：进程是资源分配单位，线程是执行单位，协程（用户态轻量级线程，如 Kotlin Coroutines）。</li><li><strong>进程通信（IPC）</strong>：管道（匿名&#x2F;命名）、共享内存（需信号量同步）、消息队列。</li><li><strong>内存管理</strong>：虚拟内存、分页&#x2F;分段机制，页面置换算法（LRU&#x2F;FIFO）。</li></ul><h3 id="十、设计模式与-AI"><a href="#十、设计模式与-AI" class="headerlink" title="十、设计模式与 AI"></a><strong>十、设计模式与 AI</strong></h3><h4 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a><strong>设计模式</strong></h4><ul><li><strong>创建型</strong>：单例模式（懒汉式&#x2F;饿汉式&#x2F;双重检查锁）、工厂模式（简单工厂&#x2F;工厂方法&#x2F;抽象工厂）。</li><li><strong>结构型</strong>：代理模式（静态&#x2F;动态代理）、装饰器模式（增强对象功能）。</li><li><strong>行为型</strong>：策略模式（算法封装）、观察者模式（发布-订阅）。</li></ul><h4 id="AI-与大模型"><a href="#AI-与大模型" class="headerlink" title="AI 与大模型"></a><strong>AI 与大模型</strong></h4><ul><li><strong>注意力机制</strong>：自注意力（Self-Attention，如 Transformer）、交叉注意力（Cross-Attention，编码-解码交互）。</li><li><strong>Agent 开发</strong>：LangChain（工具调用、Prompt 工程）、AutoGPT（自主决策 Agent）、函数调用（Function Call）。</li><li><strong>评估指标</strong>：MRR（平均倒数排名）、BLEU（机器翻译）、ROUGE（文本摘要）。</li></ul>]]></content>
    
    
    <categories>
      
      <category>编程学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>python基础概念学习</title>
    <link href="/2025/05/26/python/"/>
    <url>/2025/05/26/python/</url>
    
    <content type="html"><![CDATA[<h1 id="python基础概念学习"><a href="#python基础概念学习" class="headerlink" title="python基础概念学习"></a>python基础概念学习</h1><h3 id="一、基础语法"><a href="#一、基础语法" class="headerlink" title="一、基础语法"></a><strong>一、基础语法</strong></h3><table><thead><tr><th><strong>知识点</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>注释</strong></td><td>- 单行注释：<code># 注释内容</code><br>- 多行注释：推荐用多行 <code>#</code>，或未被使用的三引号字符串（<code>&#39;&#39;&#39;</code> 或 <code>&quot;&quot;&quot;</code>，但不推荐）</td></tr><tr><td><strong>语句分隔</strong></td><td>- 一行多条语句：用分号 <code>;</code> 分隔（如 <code>a=1; b=2</code>）<br>- 多行语句：用 <code>\</code> 续行，或括号包裹（<code>[]</code>&#x2F;<code>&#123;&#125;</code>&#x2F;<code>()</code>）自动续行</td></tr><tr><td><strong>缩进规则</strong></td><td>代码块通过缩进（空格&#x2F;制表符）区分层级，同一缩进视为一个代码组</td></tr><tr><td><strong>print 函数</strong></td><td>- 换行输出：默认行为<br>- 不换行：<code>print(x, end=&quot;&quot;)</code>（Python 3+）</td></tr><tr><td><strong>字符串表示</strong></td><td>- 单引号 <code>&#39;</code>、双引号 <code>&quot;</code>、三引号 <code>&#39;&#39;&#39;</code>&#x2F;<code>&quot;&quot;&quot;</code>（支持多行）</td></tr></tbody></table><h3 id="二、变量与数据类型"><a href="#二、变量与数据类型" class="headerlink" title="二、变量与数据类型"></a><strong>二、变量与数据类型</strong></h3><h4 id="1-变量赋值"><a href="#1-变量赋值" class="headerlink" title="1. 变量赋值"></a><strong>1. 变量赋值</strong></h4><ul><li><strong>无需类型声明</strong>：变量动态绑定类型（如 <code>a = 1</code>，<code>a = &quot;string&quot;</code>）。  </li><li><strong>多变量赋值</strong>：  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">a = b = c = <span class="hljs-number">1</span>       <span class="hljs-comment"># 多个变量赋同一值</span><br>a, b, c = <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-string">&quot;john&quot;</span>  <span class="hljs-comment"># 多变量赋不同值</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="2-标准数据类型"><a href="#2-标准数据类型" class="headerlink" title="2. 标准数据类型"></a><strong>2. 标准数据类型</strong></h4><table><thead><tr><th><strong>类型</strong></th><th><strong>特点</strong></th><th><strong>示例</strong></th></tr></thead><tbody><tr><td><strong>不可变类型</strong></td><td>数据修改会创建新对象（<code>numbers</code>、<code>string</code>、<code>tuple</code>）</td><td><code>num = 5; num = 6</code>（新建对象）</td></tr><tr><td><strong>可变类型</strong></td><td>数据修改直接操作原对象（<code>list</code>、<code>dict</code>）</td><td><code>lst = [1]; lst.append(2)</code>（修改原列表）</td></tr></tbody></table><h4 id="3-具体类型详解"><a href="#3-具体类型详解" class="headerlink" title="3. 具体类型详解"></a><strong>3. 具体类型详解</strong></h4><ul><li><strong>数字（<code>numbers</code>）</strong>：<code>int</code>、<code>float</code>、<code>complex</code>（复数）。  </li><li><strong>字符串（<code>string</code>）</strong>：  <ul><li>索引：左边界包含，右边界不包含（如 <code>s = &quot;abc&quot;; s[0:2]</code> 结果为 <code>&quot;ab&quot;</code>）。  </li><li>多行字符串：用三引号 <code>&#39;&#39;&#39;</code> 或 <code>&quot;&quot;&quot;</code>。</li></ul></li><li><strong>列表（<code>list</code>）</strong>：  <ul><li>支持嵌套，如 <code>lst = [1, &quot;a&quot;, [3, 4]]</code>。  </li><li>截取语法：<code>lst[start:end:step]</code>（步长默认 1），如 <code>lst[1:4:2]</code>。</li></ul></li><li><strong>元组（<code>tuple</code>）</strong>：  <ul><li>用 <code>()</code> 标识，元素不可修改，可重复，如 <code>tup = (1, 2, 1)</code>。</li></ul></li><li><strong>字典（<code>dict</code>）</strong>：  <ul><li>无序键值对，键必须为不可变类型（如 <code>int</code>、<code>str</code>、<code>tuple</code>），值可为任意类型。  </li><li>操作示例：  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">dic = &#123;<span class="hljs-number">1</span>: <span class="hljs-string">&quot;one&quot;</span>, <span class="hljs-string">&quot;two&quot;</span>: <span class="hljs-number">2</span>&#125;<br>dic[<span class="hljs-number">2</span>] = <span class="hljs-string">&quot;three&quot;</span>  <span class="hljs-comment"># 添加/更新键值对</span><br><span class="hljs-keyword">del</span> dic[<span class="hljs-number">1</span>]        <span class="hljs-comment"># 删除键值对</span><br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="三、运算符"><a href="#三、运算符" class="headerlink" title="三、运算符"></a><strong>三、运算符</strong></h3><table><thead><tr><th><strong>类别</strong></th><th><strong>运算符</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>算术运算符</strong></td><td><code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>、<code>%</code>、<code>**</code>（幂）、<code>//</code>（取整除）</td><td><code>3 ** 2 = 9</code>，<code>7 // 3 = 2</code></td></tr><tr><td><strong>位运算符</strong></td><td><code>&amp;</code>（与）、&#96;</td><td><code>（或）、</code>^<code>（异或）、</code>~&#96;（取反）、<code>&lt;&lt;</code>（左移）、<code>&gt;&gt;</code>（右移）</td></tr><tr><td><strong>逻辑运算符</strong></td><td><code>and</code>、<code>or</code>、<code>not</code></td><td><code>True and False = False</code></td></tr><tr><td><strong>成员运算符</strong></td><td><code>in</code>、<code>not in</code></td><td><code>2 in [1,2,3] = True</code></td></tr><tr><td><strong>身份运算符</strong></td><td><code>is</code>、<code>is not</code></td><td>检查两个对象是否为同一实例（如 <code>a is b</code> 判断内存地址是否相同）</td></tr></tbody></table><h3 id="四、流程控制（条件与循环）"><a href="#四、流程控制（条件与循环）" class="headerlink" title="四、流程控制（条件与循环）"></a><strong>四、流程控制（条件与循环）</strong></h3><h4 id="1-条件语句（if-elif-else）"><a href="#1-条件语句（if-elif-else）" class="headerlink" title="1. 条件语句（if-elif-else）"></a><strong>1. 条件语句（<code>if-elif-else</code>）</strong></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> condition1:<br>    <span class="hljs-comment"># 代码块1</span><br><span class="hljs-keyword">elif</span> condition2:<br>    <span class="hljs-comment"># 代码块2</span><br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-comment"># 代码块3</span><br></code></pre></td></tr></table></figure><ul><li>同一行简写：<code>if var == 100: print(&quot;值为100&quot;)</code>。</li></ul><h4 id="2-循环语句"><a href="#2-循环语句" class="headerlink" title="2. 循环语句"></a><strong>2. 循环语句</strong></h4><table><thead><tr><th><strong>类型</strong></th><th><strong>语法</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong><code>while</code> 循环</strong></td><td><code>python&lt;br&gt;while condition:&lt;br&gt;    # 循环体&lt;br&gt;else:&lt;br&gt;    # 条件为False时执行&lt;br&gt;</code></td><td><code>else</code> 块在循环正常结束（未被 <code>break</code> 中断）时执行。</td></tr><tr><td><strong><code>for</code> 循环</strong></td><td><code>python&lt;br&gt;for item in iterable:&lt;br&gt;    # 循环体&lt;br&gt;else:&lt;br&gt;    # 循环结束后执行&lt;br&gt;</code></td><td>遍历可迭代对象（如字符串、列表、元组），<code>else</code> 块同上。</td></tr><tr><td><strong>循环控制</strong></td><td><code>break</code>（退出整个循环）、<code>continue</code>（跳过当前迭代）、<code>pass</code>（占位符，不执行任何操作）</td><td><code>pass</code> 用于避免语法错误（如定义空函数）。</td></tr></tbody></table><h3 id="五、函数"><a href="#五、函数" class="headerlink" title="五、函数"></a><strong>五、函数</strong></h3><h4 id="1-定义与调用"><a href="#1-定义与调用" class="headerlink" title="1. 定义与调用"></a><strong>1. 定义与调用</strong></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">function_name</span>(<span class="hljs-params">arg1, arg2=默认值, *args, **kwargs</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;文档字符串（可通过 __doc__ 访问）&quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 函数体</span><br>    <span class="hljs-keyword">return</span> 返回值<br></code></pre></td></tr></table></figure><ul><li><strong>参数类型</strong>：  <ul><li><strong>位置参数</strong>：<code>arg1</code>（必须按顺序传递）。  </li><li><strong>默认参数</strong>：<code>arg2=默认值</code>（可选传递）。  </li><li><strong>不定长参数</strong>：  <ul><li><code>*args</code>：接收任意数量的位置参数（转为元组）。  </li><li><code>**kwargs</code>：接收任意数量的关键字参数（转为字典）。</li></ul></li></ul></li><li><strong>关键字参数</strong>：调用时指定参数名（如 <code>function_name(arg2=2)</code>）。</li></ul><h4 id="2-匿名函数（lambda）"><a href="#2-匿名函数（lambda）" class="headerlink" title="2. 匿名函数（lambda）"></a><strong>2. 匿名函数（<code>lambda</code>）</strong></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">sum</span> = <span class="hljs-keyword">lambda</span> x, y: x + y  <span class="hljs-comment"># 等价于 def sum(x, y): return x + y</span><br></code></pre></td></tr></table></figure><ul><li>适用于简单函数，无需命名。</li></ul><h3 id="六、模块与包"><a href="#六、模块与包" class="headerlink" title="六、模块与包"></a><strong>六、模块与包</strong></h3><ul><li><strong>导入模块</strong>：  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> module_name          <span class="hljs-comment"># 导入模块（如 import math）</span><br><span class="hljs-keyword">from</span> module_name <span class="hljs-keyword">import</span> func <span class="hljs-comment"># 从模块导入函数（如 from math import sqrt）</span><br><span class="hljs-keyword">from</span> module_name <span class="hljs-keyword">import</span> *    <span class="hljs-comment"># 导入模块所有内容（不推荐，可能引发命名冲突）</span><br></code></pre></td></tr></table></figure></li><li><strong>常用函数</strong>：  <ul><li><code>dir(module)</code>：查看模块中定义的名称（函数、变量等）。  </li><li><code>globals()</code>&#x2F;<code>locals()</code>：返回全局&#x2F;局部作用域中的名称字典。  </li><li><code>reload(module)</code>：重新加载模块（Python 3 需从 <code>importlib</code> 导入）。</li></ul></li></ul><h3 id="七、输入输出（IO）"><a href="#七、输入输出（IO）" class="headerlink" title="七、输入输出（IO）"></a><strong>七、输入输出（IO）</strong></h3><h4 id="1-输入函数"><a href="#1-输入函数" class="headerlink" title="1. 输入函数"></a><strong>1. 输入函数</strong></h4><ul><li>**<code>input(prompt)</code>**：读取用户输入，返回字符串（输入表达式会被求值）。  </li><li>**<code>raw_input(prompt)</code>**：Python 2 中的输入函数，等价于 Python 3 的 <code>input</code>。</li></ul><h4 id="2-文件操作"><a href="#2-文件操作" class="headerlink" title="2. 文件操作"></a><strong>2. 文件操作</strong></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 打开文件（模式：&#x27;r&#x27;读，&#x27;w&#x27;写，&#x27;a&#x27;追加，&#x27;b&#x27;二进制模式）</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;file.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, encoding=<span class="hljs-string">&quot;utf-8&quot;</span>) <span class="hljs-keyword">as</span> f:<br>    content = f.read()     <span class="hljs-comment"># 读取全部内容</span><br>    lines = f.readlines()  <span class="hljs-comment"># 按行读取为列表</span><br>    line = f.readline()    <span class="hljs-comment"># 读取一行</span><br><br><span class="hljs-comment"># 写入文件</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;file.txt&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>) <span class="hljs-keyword">as</span> f:<br>    f.write(<span class="hljs-string">&quot;内容&quot;</span>)        <span class="hljs-comment"># 写入字符串</span><br>    f.writelines([<span class="hljs-string">&quot;行1\n&quot;</span>, <span class="hljs-string">&quot;行2\n&quot;</span>])  <span class="hljs-comment"># 写入列表中的多行</span><br></code></pre></td></tr></table></figure><ul><li><strong>文件指针操作</strong>：  <ul><li><code>f.tell()</code>：获取当前位置（字节数）。  </li><li><code>f.seek(offset, whence)</code>：移动指针（<code>whence=0</code> 为文件开头，<code>1</code> 为当前位置，<code>2</code> 为文件末尾）。</li></ul></li></ul><h3 id="八、异常处理"><a href="#八、异常处理" class="headerlink" title="八、异常处理"></a><strong>八、异常处理</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    <span class="hljs-comment"># 可能引发异常的代码</span><br><span class="hljs-keyword">except</span> ExceptionType <span class="hljs-keyword">as</span> e:  <span class="hljs-comment"># 捕获特定异常</span><br>    <span class="hljs-comment"># 异常处理逻辑</span><br><span class="hljs-keyword">except</span>:  <span class="hljs-comment"># 捕获所有异常</span><br>    <span class="hljs-comment"># 通用处理逻辑</span><br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-comment"># 无异常时执行</span><br><span class="hljs-keyword">finally</span>:<br>    <span class="hljs-comment"># 无论是否异常都会执行（常用于资源释放）</span><br></code></pre></td></tr></table></figure><ul><li><strong>主动抛出异常</strong>：<code>raise Exception(&quot;错误信息&quot;)</code>。  </li><li><strong>自定义异常</strong>：继承 <code>Exception</code> 类，如 <code>class MyError(Exception): pass</code>。</li></ul><h3 id="九、面向对象编程（OOP）"><a href="#九、面向对象编程（OOP）" class="headerlink" title="九、面向对象编程（OOP）"></a><strong>九、面向对象编程（OOP）</strong></h3><h4 id="1-类与对象"><a href="#1-类与对象" class="headerlink" title="1. 类与对象"></a><strong>1. 类与对象</strong></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassName</span>:<br>    <span class="hljs-comment"># 类属性</span><br>    class_var = <span class="hljs-string">&quot;类变量&quot;</span><br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, param</span>):  <span class="hljs-comment"># 构造方法</span><br>        <span class="hljs-variable language_">self</span>.instance_var = param  <span class="hljs-comment"># 实例属性</span><br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">method</span>(<span class="hljs-params">self</span>):  <span class="hljs-comment"># 实例方法（必须包含 self 参数）</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-variable language_">self</span>.instance_var)<br>    <br><span class="hljs-meta">    @classmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">class_method</span>(<span class="hljs-params">cls</span>):  <span class="hljs-comment"># 类方法（通过 @classmethod 装饰）</span><br>        <span class="hljs-built_in">print</span>(cls.class_var)<br>    <br><span class="hljs-meta">    @staticmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">static_method</span>():  <span class="hljs-comment"># 静态方法（无需 self/cls 参数）</span><br>        <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><ul><li><strong>实例化</strong>：<code>obj = ClassName(&quot;参数&quot;)</code>。  </li><li><strong>属性访问</strong>：<code>obj.instance_var</code>、<code>ClassName.class_var</code>。</li></ul><h4 id="2-继承与多态"><a href="#2-继承与多态" class="headerlink" title="2. 继承与多态"></a><strong>2. 继承与多态</strong></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SubClass</span>(<span class="hljs-title class_ inherited__">ParentClass</span>):  <span class="hljs-comment"># 单继承</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, param1, param2</span>):<br>        <span class="hljs-built_in">super</span>().__init__(param1)  <span class="hljs-comment"># 调用父类构造方法</span><br>        <span class="hljs-variable language_">self</span>.param2 = param2<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MultiSub</span>(Parent1, Parent2):  <span class="hljs-comment"># 多继承</span><br>    <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><h4 id="3-访问控制"><a href="#3-访问控制" class="headerlink" title="3. 访问控制"></a><strong>3. 访问控制</strong></h4><table><thead><tr><th><strong>命名规则</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><code>_attr</code></td><td>保护属性（约定子类可访问，外部不建议直接访问）。</td></tr><tr><td><code>__attr</code></td><td>私有属性（外部不可直接访问，需通过 <code>obj._ClassName__attr</code> 访问）。</td></tr><tr><td><code>__attr__</code></td><td>特殊方法&#x2F;属性（如 <code>__init__</code>、<code>__str__</code>，Python 内置）。</td></tr></tbody></table><h3 id="十、其他重要知识点"><a href="#十、其他重要知识点" class="headerlink" title="十、其他重要知识点"></a><strong>十、其他重要知识点</strong></h3><ol><li><strong>数据类型转换</strong>：  <ul><li><code>int(x)</code>、<code>float(x)</code>、<code>str(x)</code>、<code>list(x)</code>、<code>tuple(x)</code>、<code>dict(x)</code>。</li></ul></li><li><strong>解包（Unpacking）</strong>：  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">a, b, c = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]  <span class="hljs-comment"># a=1, b=2, c=3</span><br></code></pre></td></tr></table></figure></li><li><strong>列表推导式</strong>：  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">squares = [x**<span class="hljs-number">2</span> <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>)]  <span class="hljs-comment"># 生成 [0, 1, 4, ..., 81]</span><br></code></pre></td></tr></table></figure></li><li><strong>生成器（Generator）</strong>：  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">gen = (x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>))  <span class="hljs-comment"># 惰性生成序列，节省内存</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="十一、异步编程（asyncio）"><a href="#十一、异步编程（asyncio）" class="headerlink" title="十一、异步编程（asyncio）"></a><strong>十一、异步编程（asyncio）</strong></h3><h4 id="1-核心概念"><a href="#1-核心概念" class="headerlink" title="1. 核心概念"></a><strong>1. 核心概念</strong></h4><table><thead><tr><th><strong>术语</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>协程（Coroutine）</strong></td><td>由 <code>async def</code> 定义的异步函数，可通过 <code>await</code> 暂停执行并让出 CPU。</td></tr><tr><td><strong>事件循环（Event Loop）</strong></td><td>单线程调度器，负责监听和分发异步任务，是异步程序的执行核心。</td></tr><tr><td><strong>非阻塞IO</strong></td><td>允许程序在等待IO操作时继续执行其他任务，提升并发效率。</td></tr></tbody></table><h4 id="2-基础语法"><a href="#2-基础语法" class="headerlink" title="2. 基础语法"></a><strong>2. 基础语法</strong></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> asyncio<br><br><span class="hljs-comment"># 定义协程函数</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">fetch_data</span>(<span class="hljs-params">url</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;开始请求 <span class="hljs-subst">&#123;url&#125;</span>&quot;</span>)<br>    <span class="hljs-comment"># 模拟IO操作，让出控制权</span><br>    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">1</span>)  <br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;完成请求 <span class="hljs-subst">&#123;url&#125;</span>&quot;</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">f&quot;数据: <span class="hljs-subst">&#123;url&#125;</span>&quot;</span><br><br><span class="hljs-comment"># 主函数（也是协程）</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    <span class="hljs-comment"># 创建多个协程任务</span><br>    task1 = fetch_data(<span class="hljs-string">&quot;https://api1.com&quot;</span>)<br>    task2 = fetch_data(<span class="hljs-string">&quot;https://api2.com&quot;</span>)<br>    <br>    <span class="hljs-comment"># 并发执行多个任务</span><br>    results = <span class="hljs-keyword">await</span> asyncio.gather(task1, task2)<br>    <span class="hljs-built_in">print</span>(results)<br><br><span class="hljs-comment"># 启动事件循环</span><br>asyncio.run(main())  <span class="hljs-comment"># Python 3.7+</span><br></code></pre></td></tr></table></figure><h4 id="3-关键机制"><a href="#3-关键机制" class="headerlink" title="3. 关键机制"></a><strong>3. 关键机制</strong></h4><ul><li><strong>await 关键字</strong>：<br>用于暂停协程执行，等待另一个协程或异步操作完成（如 <code>await func()</code>）。  </li><li><strong>任务（Task）</strong>：<br>对协程的封装，可独立调度执行（如 <code>task = asyncio.create_task(coro())</code>）。  </li><li><strong>异步迭代器</strong>：<br>通过 <code>async for</code> 和 <code>__aiter__</code>&#x2F;<code>__anext__</code> 实现异步迭代（如异步读取文件）。</li></ul><h3 id="十二、多线程与多进程"><a href="#十二、多线程与多进程" class="headerlink" title="十二、多线程与多进程"></a><strong>十二、多线程与多进程</strong></h3><h4 id="1-多线程（threading）"><a href="#1-多线程（threading）" class="headerlink" title="1. 多线程（threading）"></a><strong>1. 多线程（threading）</strong></h4><ul><li><strong>适用场景</strong>：IO密集型任务（如网络请求、文件读写）。  </li><li><strong>特点</strong>：  <ul><li>共享全局变量，需通过锁（<code>threading.Lock</code>）解决线程安全问题。  </li><li>受GIL（全局解释器锁）限制，无法真正并行。</li></ul></li><li><strong>示例</strong>：  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">worker</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;线程执行中&quot;</span>)<br><br>thread = threading.Thread(target=worker)<br>thread.start()<br></code></pre></td></tr></table></figure></li></ul><h4 id="2-多进程（multiprocessing）"><a href="#2-多进程（multiprocessing）" class="headerlink" title="2. 多进程（multiprocessing）"></a><strong>2. 多进程（multiprocessing）</strong></h4><ul><li><strong>适用场景</strong>：CPU密集型任务（如科学计算、图像处理）。  </li><li><strong>特点</strong>：  <ul><li>每个进程有独立的内存空间，无GIL限制，可真正并行。  </li><li>进程间通信需通过 <code>Queue</code>、<code>Pipe</code> 等方式。</li></ul></li><li><strong>示例</strong>：  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> multiprocessing <span class="hljs-keyword">import</span> Process<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">process_task</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;进程执行中&quot;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    p = Process(target=process_task)<br>    p.start()<br></code></pre></td></tr></table></figure></li></ul><h3 id="十三、装饰器（Decorator）"><a href="#十三、装饰器（Decorator）" class="headerlink" title="十三、装饰器（Decorator）"></a><strong>十三、装饰器（Decorator）</strong></h3><h4 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a><strong>1. 基本概念</strong></h4><ul><li><strong>作用</strong>：在不修改原函数代码的情况下，为函数添加额外功能（如日志、计时、权限验证）。  </li><li><strong>本质</strong>：接收函数作为参数并返回新函数的高阶函数。</li></ul><h4 id="2-简单示例"><a href="#2-简单示例" class="headerlink" title="2. 简单示例"></a><strong>2. 简单示例</strong></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">timer_decorator</span>(<span class="hljs-params">func</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">*args, **kwargs</span>):<br>        start_time = time.time()<br>        result = func(*args, **kwargs)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;函数 <span class="hljs-subst">&#123;func.__name__&#125;</span> 执行耗时: <span class="hljs-subst">&#123;time.time() - start_time&#125;</span>s&quot;</span>)<br>        <span class="hljs-keyword">return</span> result<br>    <span class="hljs-keyword">return</span> wrapper<br><br><span class="hljs-meta">@timer_decorator  </span><span class="hljs-comment"># 等价于 func = timer_decorator(func)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">my_function</span>():<br>    time.sleep(<span class="hljs-number">1</span>)<br><br>my_function()  <span class="hljs-comment"># 调用时自动应用装饰器逻辑</span><br></code></pre></td></tr></table></figure><h4 id="3-进阶用法"><a href="#3-进阶用法" class="headerlink" title="3. 进阶用法"></a><strong>3. 进阶用法</strong></h4><ul><li><strong>带参数的装饰器</strong>：通过多层嵌套实现。  </li><li><strong>类装饰器</strong>：使用类的 <code>__call__</code> 方法实现。</li></ul><h3 id="十四、迭代器与生成器"><a href="#十四、迭代器与生成器" class="headerlink" title="十四、迭代器与生成器"></a><strong>十四、迭代器与生成器</strong></h3><h4 id="1-迭代器（Iterator）"><a href="#1-迭代器（Iterator）" class="headerlink" title="1. 迭代器（Iterator）"></a><strong>1. 迭代器（Iterator）</strong></h4><ul><li><strong>协议</strong>：实现 <code>__iter__()</code> 和 <code>__next__()</code> 方法。  </li><li><strong>示例</strong>：  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyRange</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, stop</span>):<br>        <span class="hljs-variable language_">self</span>.stop = stop<br>        <span class="hljs-variable language_">self</span>.current = <span class="hljs-number">0</span><br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__iter__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span><br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__next__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.current &lt; <span class="hljs-variable language_">self</span>.stop:<br>            value = <span class="hljs-variable language_">self</span>.current<br>            <span class="hljs-variable language_">self</span>.current += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">return</span> value<br>        <span class="hljs-keyword">raise</span> StopIteration<br><br><span class="hljs-comment"># 使用迭代器</span><br><span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> MyRange(<span class="hljs-number">3</span>):<br>    <span class="hljs-built_in">print</span>(num)  <span class="hljs-comment"># 输出 0, 1, 2</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="2-生成器（Generator）"><a href="#2-生成器（Generator）" class="headerlink" title="2. 生成器（Generator）"></a><strong>2. 生成器（Generator）</strong></h4><ul><li><strong>定义方式</strong>：  <ul><li><strong>生成器函数</strong>：使用 <code>yield</code> 关键字（如 <code>def gen(): yield 1</code>）。  </li><li><strong>生成器表达式</strong>：类似列表推导式，用圆括号（如 <code>(x for x in range(3))</code>）。</li></ul></li><li><strong>特点</strong>：惰性求值，节省内存，适用于大数据流处理。</li></ul><h3 id="十五、元编程"><a href="#十五、元编程" class="headerlink" title="十五、元编程"></a><strong>十五、元编程</strong></h3><h4 id="1-动态创建类"><a href="#1-动态创建类" class="headerlink" title="1. 动态创建类"></a><strong>1. 动态创建类</strong></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 使用 type 动态创建类</span><br>MyClass = <span class="hljs-built_in">type</span>(<span class="hljs-string">&#x27;MyClass&#x27;</span>, (<span class="hljs-built_in">object</span>,), &#123;<span class="hljs-string">&#x27;attr&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;method&#x27;</span>: <span class="hljs-keyword">lambda</span> <span class="hljs-variable language_">self</span>: <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Hello&#x27;</span>)&#125;)<br><br>obj = MyClass()<br>obj.method()  <span class="hljs-comment"># 输出: Hello</span><br></code></pre></td></tr></table></figure><h4 id="2-元类（Metaclass）"><a href="#2-元类（Metaclass）" class="headerlink" title="2. 元类（Metaclass）"></a><strong>2. 元类（Metaclass）</strong></h4><ul><li><strong>作用</strong>：控制类的创建过程（如验证、修改类属性）。  </li><li><strong>示例</strong>：  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Meta</span>(<span class="hljs-title class_ inherited__">type</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__new__</span>(<span class="hljs-params">cls, name, bases, attrs</span>):<br>        <span class="hljs-comment"># 添加类属性</span><br>        attrs[<span class="hljs-string">&#x27;meta_attr&#x27;</span>] = <span class="hljs-string">&#x27;meta_value&#x27;</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>().__new__(cls, name, bases, attrs)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>(metaclass=Meta):<br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-built_in">print</span>(MyClass.meta_attr)  <span class="hljs-comment"># 输出: meta_value</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="十六、异步IO实战技巧"><a href="#十六、异步IO实战技巧" class="headerlink" title="十六、异步IO实战技巧"></a><strong>十六、异步IO实战技巧</strong></h3><h4 id="1-异步HTTP请求"><a href="#1-异步HTTP请求" class="headerlink" title="1. 异步HTTP请求"></a><strong>1. 异步HTTP请求</strong></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> aiohttp<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-params">session, url</span>):<br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.get(url) <span class="hljs-keyword">as</span> response:<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> response.text()<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> aiohttp.ClientSession() <span class="hljs-keyword">as</span> session:<br>        html = <span class="hljs-keyword">await</span> fetch(session, <span class="hljs-string">&#x27;https://example.com&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(html)<br></code></pre></td></tr></table></figure><h4 id="2-异步文件操作"><a href="#2-异步文件操作" class="headerlink" title="2. 异步文件操作"></a><strong>2. 异步文件操作</strong></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> aiofiles<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">write_file</span>():<br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> aiofiles.<span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;test.txt&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>        <span class="hljs-keyword">await</span> f.write(<span class="hljs-string">&#x27;Hello, async!&#x27;</span>)<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">read_file</span>():<br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> aiofiles.<span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;test.txt&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>        content = <span class="hljs-keyword">await</span> f.read()<br>        <span class="hljs-built_in">print</span>(content)<br></code></pre></td></tr></table></figure><h3 id="十七、性能优化"><a href="#十七、性能优化" class="headerlink" title="十七、性能优化"></a><strong>十七、性能优化</strong></h3><h4 id="1-内置工具"><a href="#1-内置工具" class="headerlink" title="1. 内置工具"></a><strong>1. 内置工具</strong></h4><ul><li><strong>时间分析</strong>：<code>timeit</code> 模块测量代码执行时间。  </li><li><strong>内存分析</strong>：<code>memory_profiler</code> 库监控内存使用。</li></ul><h4 id="2-优化技巧"><a href="#2-优化技巧" class="headerlink" title="2. 优化技巧"></a><strong>2. 优化技巧</strong></h4><ul><li><strong>避免全局变量</strong>：减少命名空间查找开销。  </li><li><strong>使用生成器</strong>：替代大列表，节省内存。  </li><li><strong>内置函数优先</strong>：如 <code>map()</code>、<code>filter()</code> 比纯 Python 循环更高效。</li></ul><h3 id="十八、常用标准库"><a href="#十八、常用标准库" class="headerlink" title="十八、常用标准库"></a><strong>十八、常用标准库</strong></h3><table><thead><tr><th><strong>模块</strong></th><th><strong>用途</strong></th></tr></thead><tbody><tr><td><strong>os</strong></td><td>操作系统接口（文件操作、路径处理）。</td></tr><tr><td><strong>sys</strong></td><td>Python 解释器相关参数（如命令行参数、退出状态）。</td></tr><tr><td><strong>json</strong></td><td>JSON 数据解析与序列化。</td></tr><tr><td><strong>re</strong></td><td>正则表达式匹配。</td></tr><tr><td><strong>datetime</strong></td><td>日期和时间处理。</td></tr><tr><td><strong>logging</strong></td><td>日志记录（配置日志级别、输出格式）。</td></tr><tr><td><strong>requests</strong></td><td>HTTP 请求（Python 3 推荐使用 <code>aiohttp</code> 实现异步请求）。</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>编程学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>利用Agent批量制作anki卡片</title>
    <link href="/2025/05/25/picsubtoanki/"/>
    <url>/2025/05/25/picsubtoanki/</url>
    
    <content type="html"><![CDATA[<h1 id="利用Agent批量制作anki卡片"><a href="#利用Agent批量制作anki卡片" class="headerlink" title="利用Agent批量制作anki卡片"></a>利用Agent批量制作anki卡片</h1><p>我一直都希望，在看完一部动画之后，能更便捷的把所有生词导入到anki卡片中。而使用普通的划词工具，总是显得不够智能，表现在：</p><ul><li>对于俚语等特殊表达，词典中没有直接对应的意思</li><li>查询单词时总要费劲心思的查询他在特定语句中的意义</li></ul><p>于是，我设计了<a href="https://github.com/Mayeggx/PicSubToAnki">PicSubToAnki</a>这款软件。</p><h2 id="制作卡片的素材"><a href="#制作卡片的素材" class="headerlink" title="制作卡片的素材"></a>制作卡片的素材</h2><p>实际上，要制作一个生词的anki卡片，需要的就是当前的字幕、需要查询的单词、当前的截图。<br>这样一般就能获得一个有上下文语境、并且能够会想起当前场景的优质卡片了。</p><p>所以，这个软件的原素材是<code>当前字幕为文件名的截图文件</code>，将这种截图文件制作为anki卡片。<br>为了获得这样的截图文件，请使用<a href="https://github.com/mpv-player/mpv">mpv播放器</a>，并打开<code>mpv.conf</code>文件，<br>加入设置<code>screenshot-template=&quot;%&#123;sub-text&#125;&quot;</code>。这样就可以得到这款软件所需要的文件类型。</p><p>在看我完一集动画后，就可以得到很多这样的截图文件，把他们导入这个软件，就能批量制作卡片了。</p><h2 id="软件的结构"><a href="#软件的结构" class="headerlink" title="软件的结构"></a>软件的结构</h2><p>软件主要分为三个部分：</p><ul><li><code>main.py</code>使用python的内置图形界面tkinter实现可视化界面，实现截图文件的打开预览，并调用其他模块。</li><li><code>anki_connet.py</code>主要用于接收anki卡片的字段，通过AnkiConnect向电脑的anki客户端发送创建卡片的请求。</li><li><code>openai_utils.py</code>用于调用大模型的api，将接收到的字幕和单词，结构化的返回其释义、语境解释等信息。</li></ul><p>因此，在设计这个软件时，我体验了设计prompt、修改prompt、处理大模型的结构化信息的过程。<br>以批量添加时的prompt为例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">construct_batch_prompt_jp</span>(<span class="hljs-params">self, pairs</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;构造批量查询的提示词（多对subtitle和key）&quot;&quot;&quot;</span><br>        pair_descriptions = []<br>        <span class="hljs-keyword">for</span> i, (subtitle, key) <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(pairs):<br>            pair_descriptions.append(<span class="hljs-string">f&quot;&quot;&quot;</span><br><span class="hljs-string">对<span class="hljs-subst">&#123;i + <span class="hljs-number">1</span>&#125;</span>:</span><br><span class="hljs-string">例句：<span class="hljs-subst">&#123;subtitle&#125;</span></span><br><span class="hljs-string">单词：<span class="hljs-subst">&#123;key&#125;</span></span><br><span class="hljs-string">&quot;&quot;&quot;</span>)<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">f&quot;&quot;&quot;请根据提供的多组例句和单词，为每组返回以下结构化信息：</span><br><span class="hljs-string">1. 日文单词原型（如果是变形，返回原形）</span><br><span class="hljs-string">2. 日文的发音</span><br><span class="hljs-string">3. 单词在词典中的日文释义（不包含单词本身，必须只有日文）</span><br><span class="hljs-string">4. 对应的例句，并将单词部分用&lt;b&gt;原词&lt;/b&gt;的形式包围</span><br><span class="hljs-string">5. 用中文结合语境解释一下当前单词的意思</span><br><span class="hljs-string"></span><br><span class="hljs-string">请为每个例句-单词对返回独立的JSON对象，用数组格式返回所有结果：</span><br><span class="hljs-string">示例输入：</span><br><span class="hljs-string">对1:</span><br><span class="hljs-string">例句：連絡先 聞くの忘れたって わめいてたよ</span><br><span class="hljs-string">单词：わめいて</span><br><span class="hljs-string">对2:</span><br><span class="hljs-string">例句：胸ぺッタンコのくせに</span><br><span class="hljs-string">单词：胸</span><br><span class="hljs-string">示例格式：</span><br><span class="hljs-string">[</span><br><span class="hljs-string">    &#123;&#123;</span><br><span class="hljs-string">        &quot;单词&quot;: &quot;喚く&quot;,</span><br><span class="hljs-string">        &quot;音标&quot;: &quot;わめく&quot;,</span><br><span class="hljs-string">        &quot;意义&quot;: &quot;①大声でさけぶ。②騒ぎ立てる。&quot;</span><br><span class="hljs-string">        &quot;例句&quot;: &quot;連絡先 聞くの忘れたって　&lt;b&gt;わめいて&lt;/b&gt;たよ&quot;</span><br><span class="hljs-string">        &quot;笔记&quot;: &quot;「わめいてた」是动词「わめく」（叫嚷、吵闹）的过去进行时，表示“（当时）在大声抱怨/嚷嚷”。句中指对方因忘记询问联系方式而焦急或生气地吵闹，带有责备或夸张语气。&quot;</span><br><span class="hljs-string">    &#125;&#125;,</span><br><span class="hljs-string">    &#123;&#123;</span><br><span class="hljs-string">        &quot;单词&quot;: &quot;胸&quot;,</span><br><span class="hljs-string">        &quot;音标&quot;: &quot;むね&quot;,</span><br><span class="hljs-string">        &quot;意义&quot;: &quot;①人や動物の体の前面の一部分。乳房がある部分。②心の中。内面的な感情。&quot;,</span><br><span class="hljs-string">        &quot;例句&quot;: &quot;&lt;b&gt;胸&lt;/b&gt;ぺッタンコのくせに&quot;,</span><br><span class="hljs-string">        &quot;笔记&quot;: &quot;「胸」在这里指的是胸部，特指人体上半身的前部区域，在这个例句中具体指向平坦的胸部（即没有丰满的乳房）。语境中可能带有一些调侃或自嘲的意味，描述胸部平坦的状态。&quot;</span><br><span class="hljs-string">    &#125;&#125;</span><br><span class="hljs-string">]</span><br><span class="hljs-string"></span><br><span class="hljs-string">需要分析的例句-单词对：</span><br><span class="hljs-string"><span class="hljs-subst">&#123;<span class="hljs-string">&quot;&quot;</span>.join(pair_descriptions)&#125;</span></span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></td></tr></table></figure><p>让大模型返回结果试验，并分析这个prompt，可以总结几点经验：</p><ol><li>给出具体的步骤，让大模型一步步的执行</li><li>给出具体示例</li><li>注意在返回json时，不要让大模型返回双引号，因为这可能导致解析json的报错。可以在示例中使用「」提示大模型防止使用双引号。其实更彻底的做法，是让大模型返回xml格式的数据。</li><li>大模型在动词的变形时经常会出现错误。或许可以在提示词里，添加一些简洁的变形规则。或者尝试调用词典中常见的获取动词原型的函数。</li></ol><p>​        </p>]]></content>
    
    
    <categories>
      
      <category>语言学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>日语学习历程</title>
    <link href="/2024/12/03/jp/"/>
    <url>/2024/12/03/jp/</url>
    
    <content type="html"><![CDATA[<h1 id="日语学习历程"><a href="#日语学习历程" class="headerlink" title="日语学习历程"></a>日语学习历程</h1><p>学了那么久日语，来写下这篇文章记录一下我的学习历程。也为感兴趣的语言学习者提供一些指引。</p><h2 id="1-N1速通流程"><a href="#1-N1速通流程" class="headerlink" title="1 N1速通流程"></a>1 N1速通流程</h2><h3 id="🎯-1-五十音"><a href="#🎯-1-五十音" class="headerlink" title="🎯 1 五十音"></a>🎯 1 五十音</h3><p>点开B站<a href="https://www.bilibili.com/video/BV1Bp4y1D747">任意的课程</a>，能做到默写即可~当然只是这样记忆很快就会消散，我们需要立即进入下一步，开始应用五十音。  </p><ul><li>有的教程可能会有声调的教学。但声调完全没必要学，读多了自然能掌握😉。  </li><li>尤其要注意与拼音英文不同的发音部分，不要光凭直觉，这将贯穿语言学习的始终✨。比如轻辅浊音、元音的开口大小。</li></ul><h3 id="📘-2-N5-N3"><a href="#📘-2-N5-N3" class="headerlink" title="📘 2 N5-N3"></a>📘 2 N5-N3</h3><h4 id="📚-教材"><a href="#📚-教材" class="headerlink" title="📚 教材"></a>📚 教材</h4><p>新标日初级上下册，上下册共48课，每天学2课加上复习大约需要6-8个小时，历时1个月⏳。根据自身情况，每天学习1课时或者一半课时均可。  </p><ul><li>这两本书虽说是初级，但整个日语<strong>最有用</strong>的内容几乎都集合在其中了🌟。  </li><li>新标日经常受诟病的地方在于：没有开始给出动词的原型。这无伤大雅，很快学到动词变形就会明朗起来~</li></ul><h4 id="📹-课程"><a href="#📹-课程" class="headerlink" title="📹 课程"></a>📹 课程</h4><p>是存在网盘里的未明天梦子老师的日语课，虽是十几年前的视频，但内容也大差不差📺。课程一方面能拓展课本，一方面能重复关键的知识点加以记忆。尽可能在观看时默默跟读👄。  </p><h4 id="📝-复习"><a href="#📝-复习" class="headerlink" title="📝 复习"></a>📝 复习</h4><p>我会记下每节课的笔记，并制作一份挖空的版本用来复习，并在当天复习昨天和大前天的内容📅。语言学习，应该有规律的按自己节奏复习，跨越长时间维度的复习是记忆的关键~  </p><h4 id="🌟-关于正反馈"><a href="#🌟-关于正反馈" class="headerlink" title="🌟 关于正反馈"></a>🌟 关于正反馈</h4><p>开始学标日的那些唐氏单词，无疑会让人感到无趣和挫败感😫。可当你学完动词的所有变形，正反馈将在此时达到高潮🎉！动词的变形看似复杂，但相较于其可以处理的无数情况，可太短小精悍了。你可以运用其去任意分析你喜欢的日语材料，感受中文翻译之下蕴含的情感，真是让人欲罢不能啊~所以如果感觉难以坚持，请再坚持一会，学到我最喜欢的动词变形吧！  </p><h3 id="🔍-N2"><a href="#🔍-N2" class="headerlink" title="🔍 N2"></a>🔍 N2</h3><h4 id="🌐-网站"><a href="#🌐-网站" class="headerlink" title="🌐 网站"></a>🌐 网站</h4><p>标准日本语初级的语法是分散的，也是不全面的，仍然有很多情况无法被分析和理解📊。关于语法、词性的部分可以在<a href="https://www.sigure.tw/">时雨之町</a>这个网站里，系统规范的再学习一遍。里面的文章很全面和深刻，看完能对日语有进一步的理解，有一种豁然开朗的感觉✨！<br>如果想要<strong>速通</strong>日语大部分内容，直接看这个网站进行学习也是可行的🚀。前提是要积累一定的词汇和语感。  </p><h4 id="📖-教材和视频"><a href="#📖-教材和视频" class="headerlink" title="📖 教材和视频"></a>📖 教材和视频</h4><p>TRY! N2。这本书的ui很好看，文章也挺有意思，把许多语法串联在一起很自然📚。我是把它当标日来学的，一边学语法，一边遇到生词就记下来。由于它不是专门的单词书，所以输入的单词量还是偏少📖。这本书的视频教学比较少，我记得我看的是一个叫迷加老师的录播。这种录播虽然冗长，但是多听听这种老师的碎碎念，作为教材之外的扩展，对语言提升还是有帮助的~  </p><h4 id="⏱️-时间安排"><a href="#⏱️-时间安排" class="headerlink" title="⏱️ 时间安排"></a>⏱️ 时间安排</h4><p>当时我的时间安排是一天6小时+，正好用4个多月学完了N2的内容⌛，当时开始的时间安排如下所示。如果没有那么多精力，佛系地学一天2小时-，1年达到N2应该绰绰有余~  </p><h3 id="📚-N1"><a href="#📚-N1" class="headerlink" title="📚 N1"></a>📚 N1</h3><p>N1阶段就是纯纯的堆砌词汇量了📚。就算是N1的语法，某种意义上也只算是固定搭配的词汇。  </p><h4 id="📖-词汇"><a href="#📖-词汇" class="headerlink" title="📖 词汇"></a>📖 词汇</h4><p>新东方日本语能力测试N1，实际上是翻译“耳から覚える日本語試験”引进的书📕。这本词汇书量大管饱，摘了很多特别经典有用的词汇，解释精准恰当。使用方法就是自己划重点、摘抄、跟读、默写✍️。  </p><h4 id="📗-语法"><a href="#📗-语法" class="headerlink" title="📗 语法"></a>📗 语法</h4><p>新完全掌握日语能力考试N1语法📘。N1的语法书内容很少，而且都不怎么用得上，古神语了属于是😂。这本书比较一般，编排的感觉有点老式。但是b站有一个<a href="https://www.bilibili.com/video/BV1iP4y1p7d8/">很接地气的教学视频</a>，配合使用学的挺有意思~  </p><h3 id="⚙️-其他工具"><a href="#⚙️-其他工具" class="headerlink" title="⚙️ 其他工具"></a>⚙️ 其他工具</h3><ul><li><a href="https://www.mojidict.com/">Moji辞书</a>。对初学者很友好的中日词典，新潮的单词收录的很全，操作简单✨。缺点是有些不规范。  </li><li><a href="https://dict.asia/">DICT.ASIA</a>。中日词典，解释简略📖。  </li><li><a href="https://www.weblio.jp/">weblio</a>。日文词典，涵盖内容很广🌐。  </li><li><a href="https://apps.ankiweb.net/">Anki</a>。记忆卡片软件，伟大无需多言🌟！  </li><li><a href="https://zh.hinative.com/">Hinative</a>。是询问本地人语言问题的网站🤝。有些逆天表达，也许只有本地人知道是什么意思。  </li><li><a href="https://mdict.org/">Mdict</a>。本地词典库📚。  </li><li><a href="https://forum.freemdict.com/">freemdict</a>。词典分享网站📤。</li></ul><h2 id="2-面向动画的日语学习"><a href="#2-面向动画的日语学习" class="headerlink" title="2 面向动画的日语学习"></a>2 面向动画的日语学习</h2><p>N1只是日语学习的开始🚀。当啃完上面基本教材，也有了通过考试的能力，当面对纯日文的生肉时，还是会感到茫然和渺小😵。略读、口语、俗语、流行语、网络用语、方言、专有名词，都是无处不在，又在教材中缺失的东西。既然我们已经经过了系统的学习，就有了分析语句并且归类学习的能力。下文将大致叙述如何通过动画和游戏学习日语，最终达到流畅地观看生肉动画、游玩原版游戏的目的🎮。  </p><p>无论是什么材料，我基本的思路是：<u>在使用过程中，摘出不理解的文本，并查询文本中的生词，最好再把他们加入到记忆卡片，定时复习</u>📌。为了减少对使用材料过程的打断，可以在结束之后统一对摘出的文本进行生词查询。  </p><h3 id="🎬-动画"><a href="#🎬-动画" class="headerlink" title="🎬 动画"></a>🎬 动画</h3><ol><li>下载生肉动画+对应日语的字幕📥。生肉动画下载<a href="https://nyaa.si/">nyaa</a>上英文字幕组压制的mkv格式的视频即可，使用外挂字幕可以自由的切换字幕，并且提取出字幕的文本。初期如果无法直接看纯日文的字幕，可以使用中文+日文，或者日文+英文的双语字幕过渡一下；日语字幕可在<a href="https://jimaku.cc/">jimaku</a>这个网站上下载~  </li><li>配置播放器⚙️。在观看动画时，如果遇到生词，我们需要播放器把当前的字幕导出。最好再自动截一张当前的图片便于之后记忆卡片的制作📸。  <ul><li>potplayer播放器可以通过快捷键复制当前字幕和截图。为了保留当前导出到剪切板的字幕，可以使用<a href="https://ditto-cp.sourceforge.io/">ditto</a>或是<a href="https://learnjapanese.moe/texthooker.html">Texthooker</a> + <a href="https://github.com/laplus-sadness/lap-clipboard-inserter">Lap Clipboard Inserter</a>组合。texthooker是一个用来接收当前设备剪切板的空页面，接收到后会将其滞留到页面中。  </li><li>MPV播放器可以通过编写<a href="https://github.com/rofe33/mpv-copyStuff">lua脚本</a>，一键保存当前的字幕和图像，并把字幕输出到文本文件中。MPV跨平台，在安卓设备上也可以使用📱。</li></ul></li><li>划词🔍。看完一集动画，会有很多未解的生词等待处理。这里推荐两个划词软件，可以在查词的同时将其导入到Anki中~  <ul><li><a href="https://github.com/themoeway/yomitan">Yomitan</a>是一个浏览器插件，而且是日语的专门划词软件，支持导入自定义的词典📖。可搭配<a href="https://learnjapanese.moe/texthooker.html">Texthooker</a> + <a href="https://github.com/laplus-sadness/lap-clipboard-inserter">Lap Clipboard Inserter</a>使用。  </li><li><a href="https://github.com/mmjang/ankihelper">Anki划词助手</a>，仅支持安卓端，目前已停止维护。但最近还有人修改了一下，出了Anki划词助手plus。支持多语言，比上面的插件功能完善许多，可以自动生成挖空的例句✨。</li></ul></li><li>卡片完善🎨。划词生成的卡片也许有不完善的地方，比如有的地方没有挖空、单词表达太生僻需要自己上网查找。可以根据自己理解加一些图片便于记忆，也可以把相关动画的截图添加到Anki卡片上📌。如图，卡片的正面为挖空的例句+图片+解释，反面则为对应的单词~</li></ol><h3 id="🎮-游戏"><a href="#🎮-游戏" class="headerlink" title="🎮 游戏"></a>🎮 游戏</h3><ol><li>打开原版游戏🎲。许多汉化的galgame会留下一个原版的启动文件，打开它需要特定的运行环境，可以安装<a href="https://github.com/xupefei/Locale-Emulator">Locale Emulater</a>来模拟转区~  </li><li>提取游戏文本📜。大部分的Galgame的游戏文本可以通过Textractor直接提取出来。<a href="https://github.com/Artikash/Textractor">Textractor</a>可以实时复制当前的文本到剪切板，或者呼出一个置顶窗口记录提取的文字。其他操作参考动画部分。如果有太多按键需要操作，可以用 pyautogui + keyboard 的脚本加以辅助~  </li><li>划词，完善卡片🔄。</li></ol><h3 id="⚖️-难易度相关"><a href="#⚖️-难易度相关" class="headerlink" title="⚖️ 难易度相关"></a>⚖️ 难易度相关</h3><ol><li>N3: 最简单的学习材料就是偏向子供向的动画，比如lovelive、偶像大师这种样板戏🎵。发生的地点在日常校园，话题只有空泛的梦想。初学可以拿她们来试试手~  </li><li>N2-N1: 普通的的日常动画📺。  </li><li>N1+：偏难的材料，比如说异世界、日本古代背景和某个领域的动画🏰，开始可能需要积累大量词汇适应。尤其是日本古代，为了耍帅，都会换一套说法~  </li><li>N1：Galgame需要一下处理大量的文字材料，如果词汇量不够，还是相当难用的😅。但正是因为文字的密度较高，且第一人称的体验接近现实，啃玩后应会有较大的提升~  </li><li>开始接触生肉，一定会有无论如何都无法解释的地方🤷。如果能了解大致意思，其实可以不用纠结小小一点。理由有二：  <ul><li>相比较使用翻译带来的信息缺失，这点缺失算不上什么✨。  </li><li>对于牙牙学语的孩子，遇见不懂的语言是常态~，不必焦虑。长时间暴露在这种未知的环境下，语言能力自然会得到潜移默化的提升🌱。</li></ul></li></ol><h2 id="3-结语"><a href="#3-结语" class="headerlink" title="3 结语"></a>3 结语</h2><p>大二那年封校，整天躺尸在床上上网课的我，决定做些什么💪。<br>晚上从图书馆走出的我，兴奋地滑动着手机中的歌词🎵。将所学的知识一点点的串联起来，理解着眼前的句子。<br>当时听到 知らない言葉を、覚えていくたび（把未曾知晓的语言，逐渐记住之时），我感觉这就是在说我自己啊😭。<br>那段<strong>我武者羅</strong>一般学习的日子，我大概永远都不会忘记吧~🌟</p>]]></content>
    
    
    <categories>
      
      <category>语言学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
